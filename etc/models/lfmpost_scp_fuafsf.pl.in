#!@PERL@ 
use strict;
use Getopt::Std;
use Time::Local;

# Ensure the ncgen program is in environment path
$ENV{PATH}="/opt/netcdf-pgi/bin:$ENV{PATH}";

# Note this is tested for cycles that are multiples of 1 hour, sub-hourly may need more development

# Setup command line options:
#    -l lapsprd (needs machine name and directory)
#    -m model type (default = mm5)
#    -a model configuration (e.g. schultz)
#       NOTE: if -a is set to "noSubDir", files will be written out to 
#             $lapsprd/fua and $lapsprd/fsf
#    -r model root (default = environment variable)
#    -d init date (yyyymmddhh, default = current hour)
#    -g model grid to process (default = 1, negative value does all grids)
#    -f number of forecasts including initial time (default = 12)
#    -i forecast increment (minutes, default = 60)
#    -s start forecast time (hours, default = 0)
#    -p model prefix (default = model dependent)
#    -w maximum wait time (seconds, default = 0);
#    -M path to Mass Store if desired
#    -S skip JETTY copy (just do Mass Store if that is chosen)
#    -x <blank> if present an awips bigfile will be created
#    -e avoid exiting if a particular file is missing (position as last argument or supply dummy value)

use vars qw($opt_a $opt_l $opt_m $opt_r $opt_d $opt_g $opt_f $opt_i $opt_p $opt_s $opt_w $opt_M $opt_S $opt_x $opt_e);
#getopt('l:m:a:r:d:g:f:i:s:p:w:M:Sxe');
getopt('lmardgfispwMSxe');

# Obtain perl module from LAPSINSTALLROOT
require "@prefix@/etc/laps_tools.pm";
require "@prefix@/etc/oputil.pm";

my $now = `date -u`;
$now = substr($now,0,length($now)-1);
print "*** LFM post script started:  $now ***\n\n";

# Define model type (default = mm5).

my $model = "mm5";
$model = $opt_m if defined($opt_m);

# Define model prefix.

my %mdlpref;
$mdlpref{"mm5"}  = "MMOUT_DOMAIN";
$mdlpref{"wrf"}  = "wrfout";
$mdlpref{"rams"} = "a";
$mdlpref{"nmm"}  = "wrfout";
$mdlpref{$model} = $opt_p if defined ($opt_p);

# Define model grids (default = 1).

my $ngrid = 1;
my (@grid,$n);
$grid[1] = 1;
$grid[1] = $opt_g if defined ($opt_g);
if ($grid[1] < 0) {
   $ngrid = abs($grid[1]);
   for ($n=1; $n<=$ngrid; $n++) {
      $grid[$n] = $n;
   }
}
print "Number of nests = $ngrid\n";

# Define model data directories.

my $lapsprd;
$lapsprd = "$opt_l" if defined($opt_l);

my $modelroot;
my $name = uc($model)."_ROOT";
$modelroot = $ENV{"$name"} if defined($ENV{"$name"});
$modelroot = "$opt_r" if defined($opt_r);

if (! defined($lapsprd)) {
  print "LAPSPRD is not defined.\n";
  exit;
}
if (! defined($modelroot)) {
  print "$name is not defined.\n";
  exit;
}

# Determine default init time based on current time.

my $time = time;
my ($yyyy, $mm, $dd, $hh) = &time::unix_to_time($time);
my $mn = "00";

# Override default time based on command line options, if present.

my(@filelist,@filelist_sorted,$nfiles,$date,$date_a9);

if ($opt_d) {
   $_ = $opt_d;
   if (/\d\d\d\d\d\d\d\d\d\d/) {
      $yyyy = substr($opt_d,0,4); 
      $mm = substr($opt_d,4,2); 
      $dd = substr($opt_d,6,2);
      $hh = substr($opt_d,8,2);
#     $mn = 0;

#     $mm = "0".$mm while(length($mm)<2);
#     $dd = "0".$dd while(length($dd)<2);
#     $hh = "0".$hh while (length($hh)<2);

      print "opt_d = $opt_d\n";
      print "yyyy = $yyyy\n";
      $date = "$yyyy$mm$dd$hh";
      print "Date from user input is $date\n";

   } else {
      print "   Invalid date: $opt_d\n";
      print "   Date format is yyyymmddhh\n";
      print "   Quit...\n";
      exit;

   }

}else{ # find latest directory available
    opendir(DIR,$modelroot);
    @filelist = grep(/\d\d\d\d\d\d\d\d/, readdir(DIR));
    @filelist_sorted = (sort @filelist);
    $nfiles = @filelist_sorted;
    print "@filelist_sorted\n";
    $date = @filelist_sorted[$nfiles-1];
    $yyyy = substr($date,0,4); 
    $mm = substr($date,4,2); 
    $dd = substr($date,6,2);
    $hh = substr($date,8,2);

    print "Date from directory is $date\n";
}

my $yy = substr($yyyy,2,2); 

my $jy = &laps_tools::get_julian_day($dd,$mm,$yyyy);
$jy = "0$jy" while(length($jy) < 3);

$date_a9="$yy$jy$hh$mn"; 

# Define forecast parameters.

my $nfcst = 12;
$nfcst = $opt_f if defined ($opt_f);

my $finc = 3;
$finc = $opt_i/60 if defined ($opt_i);

my $sfcst = 0;
$sfcst = $opt_s if defined ($opt_s);

# LAPS i4time uses a base year of 1960 while unix time uses a base year of
#  1970.  Account for this using the following parameter which is the number 
#  of seconds between 1960 and 1970.

my $decade = 315619200;

# Define wait parameters.

my $elapsed = 0;
my $waitinc = 10;
my $maxwait = 0;
$maxwait = $opt_w if defined ($opt_w);

# Echo input arguments

print "model: $model\n";
print "lapsprd: $lapsprd\n";
print "modelroot: $modelroot\n";
print "date: $date\n";
print "date_a9: $date_a9\n";
print "nfcst: $nfcst\n";
print "finc (hours): $finc\n";
print "maxwait: $maxwait\n";


my $inittime = &time::time_to_unix($mm,$dd,$yyyy,$hh,$mn,0) + $decade;
my $endsec = &time::time_to_unix($mm,$dd,$yyyy,$hh,$mn,0) + 23400;
my $current_sec = timegm(gmtime);
my $new_cycle_min;
my $g,@grid;
my $grid;

# Loop through each forecast time for JETTY copy
if (! $opt_S){ # test for skipping JETTY copy
 for ($n=0; $n<$nfcst; $n++) {
  print "loop increment is $n\n";
  $current_sec = timegm(gmtime);
  if ( $current_sec > $endsec && (! defined($opt_d)) )
  {
   $new_cycle_min = int(($current_sec - $endsec)/60.);
   print "Past expected end time of run by $new_cycle_min minutes...\n";
   print "New cycle will start in a few minutes.  So quit post processing\n";
   die;
  }

# Wait for fsf and fua file and make sure file size is greater than zero.
  my $fcst_hr = $n * $finc;
  my $fcst_time = $fcst_hr."00";
  $fcst_time = "0".$fcst_time while (length($fcst_time)<4);

  my $fua_file = "$date_a9$fcst_time".".fua";
  my $fsf_file = "$date_a9$fcst_time".".fsf";

  print "fua_file = $fua_file\n";

# Add counting for multiple domains

  my $skip;

  print "ngrid = $ngrid\n";
  for ($g=1; $g<=$ngrid; $g++) {
    $grid = $grid[$g];

    $skip = 0;
    while ( !(-e "$modelroot/$date/wrfprd/d0$grid/fua/$fua_file") && $skip==0) {
         print "file does not exist $modelroot/$date/wrfprd/d0$grid/fua/$fua_file\n";
         system ("date");
         if ($elapsed >= $maxwait) {
            print "    LFM post process wait for FUA timed out after $elapsed seconds: maxwait = $maxwait\n\n";
            print "    fua_file = $modelroot/$date/wrfprd/d0$grid/fua/$fua_file\n";
            if (! defined ($opt_e)){
                exit;
            }
            print " Skip exit, look for next file...\n";
            $skip=1;
         }else{
            $elapsed += $waitinc;
            sleep $waitinc;
         }
    }

    print "fsf_file = $fsf_file\n";

    $skip = 0;
    while ( !(-e "$modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file") && $skip==0) {
         print "file does not exist $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file\n";
         system ("date");
         if ($elapsed >= $maxwait) {
            print "    LFM post process wait for FSF timed out after $elapsed seconds: maxwait = $maxwait\n\n";
            print "    fsf_file = $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file\n";
            if (! $opt_e){
                exit;
            }
            print " Skip exit, look for next file...\n";
            $skip=1;
         }else{
            $elapsed += $waitinc;
            sleep $waitinc;
         }
    }

    print "found it, inittime: $inittime\n";
    print "elapsed time is $elapsed\n";
    system ("ls -l $modelroot/$date/wrfprd/d0$grid/fua/$fua_file");
    system ("ls -l $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file");
    sleep 10;
    $elapsed = 0;

#   Determine size of fua/fsf files
    my $waitsize = 1;

    my $fuasize;
    $fuasize = -s "$modelroot/$date/wrfprd/d0$grid/fua/$fua_file";
    $waitsize = 1;
    while ($fuasize == 0 && $waitsize <= 5) {
        print "fua size = $fuasize, wait count = $waitsize\n";
        sleep 10;
        $waitsize++;
        $fuasize = -s "$modelroot/$date/wrfprd/d0$grid/fua/$fua_file";
    }
    print "fua size = $fuasize\n";

    my $fsfsize;
    $fsfsize = -s "$modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file";
    $waitsize = 1;
    while ($fsfsize == 0 && $waitsize <= 5) {
        print "fsf size = $fsfsize, wait count = $waitsize\n";
        sleep 10;
        $waitsize++;
        $fsfsize = -s "$modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file";
    }
    print "fsf size = $fsfsize\n";

#   Send to remote directory
    system ("date");
    my $scp_cmd;

    if ($opt_a eq "noSubDir") {
      $scp_cmd = "scp $modelroot/$date/wrfprd/d0$grid/fua/$fua_file $lapsprd/d0$grid/fua";
    }else {
      $scp_cmd = "scp $modelroot/$date/wrfprd/d0$grid/fua/$fua_file $lapsprd/d0$grid/fua/$opt_m-$opt_a";
    }
    print "Running command: $scp_cmd\n";
    system ($scp_cmd);
    system ("date");

    if ($opt_a eq "noSubDir") {
      $scp_cmd = "scp $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file $lapsprd/d0$grid/fsf";
    }else {
      $scp_cmd = "scp $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file $lapsprd/d0$grid/fsf/$opt_m-$opt_a";
    }
    print "Running command: $scp_cmd\n";
    system ($scp_cmd);
    system ("date");
  } # grid loop
 } # forecast time loop

}else{ # Skip JETTY copy
 print "Skipping JETTY Copy\n";

} # test of $opt_S 

if(! defined $opt_M){
    print "no MSS copy is needed\n";
    exit;
}

# Loop through each forecast time for MSS copy
for ($n=0; $n<$nfcst; $n++) {
  print "loop increment is $n\n";
  $current_sec = timegm(gmtime);
  if ( $current_sec > $endsec && (! defined($opt_d)) )
  {
   $new_cycle_min = int(($current_sec - $endsec)/60.);
   print "Past expected end time of run by $new_cycle_min minutes...\n";
   print "New cycle will start in a few minutes.  So quit post processing\n";
   die;
  }

# Wait for fsf and fua file and make sure file size is greater than zero.
  my $fcst_hr = $n * $finc;
  my $fcst_time = $fcst_hr."00";
  $fcst_time = "0".$fcst_time while (length($fcst_time)<4);

  my $fua_file = "$date_a9$fcst_time".".fua";
  my $fsf_file = "$date_a9$fcst_time".".fsf";

  print "fua_file = $fua_file\n";

  while ( !(-e "$modelroot/$date/wrfprd/d0$grid/fua/$fua_file")) {
         print "file does not exist\n";
         if ($elapsed >= $maxwait) {
            print "    LFM post process wait for FUA timed out after $elapsed seconds: maxwait = $maxwait\n\n";
            print "    fua_file = $modelroot/$date/wrfprd/d0$grid/fua/$fua_file\n";
            if (! defined ($opt_e)){
                exit;
            }
            print " Skip exit, look for next file...\n";
         }
         $elapsed += $waitinc;
         sleep $waitinc;
  }

  print "fsf_file = $fsf_file\n";

  while ( !(-e "$modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file")) {
         print "file does not exist\n";
         if ($elapsed >= $maxwait) {
            print "    LFM post process wait for FSF timed out after $elapsed seconds: maxwait = $maxwait\n\n";
            print "    fsf_file = $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file\n";
            if (! $opt_e){
                exit;
            }
            print " Skip exit, look for next file...\n";
         }
         $elapsed += $waitinc;
         sleep $waitinc;
  }

  print "found it, inittime: $inittime\n";
  print "elapsed time is $elapsed\n";
  system ("ls -l $modelroot/$date/wrfprd/d0$grid/fua/$fua_file");
  system ("ls -l $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file");
  sleep 10;
  $elapsed = 0;

# Send to remote directory on MSS
  system ("date");

  my $msspath;
  my $mssfullpath;

# $msspath = "/mss/fsl/frd/lapb/hmt_2008";
  $msspath = $opt_M;
  $mssfullpath = "$msspath/$yyyy/$mm/$date_a9";

  my $mss_cmd;

  $mss_cmd = "mkdir -p $mssfullpath/fua/$opt_m-$opt_a";
  print "Running command: $mss_cmd\n";
  system ($mss_cmd);

# Add counting for multiple domains

  print "ngrid = $ngrid\n";
  for ($g=1; $g<=$ngrid; $g++) {
    $grid = $grid[$g];

    $mss_cmd = "cp $modelroot/$date/wrfprd/d0$grid/fua/$fua_file $mssfullpath/fua/$opt_m-$opt_a";
    print "Running command: $mss_cmd\n";
    system ($mss_cmd);
    system ("date");

    $mss_cmd = "mkdir -p $mssfullpath/fsf/$opt_m-$opt_a";
    print "Running command: $mss_cmd\n";
    system ($mss_cmd);

    $mss_cmd = "cp $modelroot/$date/wrfprd/d0$grid/fsf/$fsf_file $mssfullpath/fsf/$opt_m-$opt_a";
    print "Running command: $mss_cmd\n";
    system ($mss_cmd);
    system ("date");

  } # grid loop

} # forecast time loop

exit;
