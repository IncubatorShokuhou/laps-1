#!@PERL@
# @configure_input@
#
# ******** laps_localization.pl.in  ************************
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
use strict;
use Getopt::Long;
my($LAPSROOT,$LAPS_DATA_ROOT,$LAPS_SRC_ROOT,$quiet,$sattype,$satid);

my $result = GetOptions("lapsroot=s" => \$LAPSROOT,
			"dataroot=s" => \$LAPS_DATA_ROOT,
			"srcroot=s"  => \$LAPS_SRC_ROOT,
			"quiet" => \$quiet, 
			"sattype=s" => \$sattype,
			"satid=s" => \$satid,
			"help" => \&help_sub,
			"<>" => \&help_sub);

sub help_sub{
    print "$0 command line options (default values)\n";
    print "   --lapsroot = Root directory of the installed laps binarys (@prefix@)\n";
    print "   --dataroot = Root directory of the installed laps data (@datadir@)\n";
    print "   --srcroot  = Root directory of the laps source code    (@top_srcdir@)\n";
    print "   --sattype  = cdf, wfo, gvr, or gwc (guessed based on site)\n";
    print "   --satid    = g8 or g9 (guessed based on -100.0W)\n";
    print "   --quiet    = Do not query user for verification\n";
    print "   --help     = print this message and exit\n";
    exit;
}
umask 002;


my $thisdir = 'pwd';
chomp($thisdir);


$LAPS_SRC_ROOT="@top_srcdir@" unless($LAPS_SRC_ROOT);
$LAPSROOT="@prefix@" unless($LAPSROOT);
$LAPS_DATA_ROOT = "@datadir@" unless($LAPS_DATA_ROOT);
$ENV{LAPS_DATA_ROOT} = $LAPS_DATA_ROOT;

require "$LAPSROOT/etc/run_sys.pm";


my $FXA_DATA = $ENV{"FXA_DATA"};

if(-d "$LAPS_SRC_ROOT/data"){
    if(-d "$LAPS_DATA_ROOT"){
	&safe_cp("$LAPS_SRC_ROOT/data","$LAPS_DATA_ROOT");
    }else{
	unless($quiet){
	    print "Directory $LAPS_DATA_ROOT not found - create from $LAPS_SRC_ROOT/data? (y or n)\n";
	    my $key = getc;
	    print "$key\n";
	    exit if($key != 'y');
	}
        my $sys ="cp -r $LAPS_SRC_ROOT/data $LAPS_DATA_ROOT";
        print $sys;
	run_sys::run_sys($sys);
    }
    &update_nl("$LAPS_SRC_ROOT/data","$LAPS_DATA_ROOT");


}else{
    print "Template directory $LAPS_SRC_ROOT/data not found - proceding assuming all namelists are up to date\n";
}

if(-d $FXA_DATA){
  print "Localizing for WFO $ENV{FXA_INGEST_SITE}\n";
  $satid = &wfo_localization($LAPS_SRC_ROOT,$LAPSROOT,$LAPS_DATA_ROOT,$FXA_DATA,$satid);
  $sattype = "wfo";
}
#
# run gridgen_model to set up the static.nest7grid file 
#
# first get the info from nest7grid.parms
open(PARMS,"$LAPS_DATA_ROOT/static/nest7grid.parms");
my($xdim,$ydim,$zdim);
while(<PARMS>){
    $xdim = $1 if(/^\s+NX_L_CMN\s*=\s*(\d+),/i);
    $ydim = $1 if(/^\s+NY_L_CMN\s*=\s*(\d+),/i);
    $zdim = $1 if(/^\s+nk_laps\s*=\s*(\d+),/i);
}
close(PARMS);

if($xdim <=0 || $ydim <= 0 || $zdim<=0){
  print "$0: Error Reading grid size from $LAPS_DATA_ROOT/static/nest7grid.parms\n";
  print "nx=$xdim ny=$ydim nz=$zdim\n";
  exit -1;
}

#
# Edit the cdl files for xdim and ydim
#
unless(-d "$LAPS_DATA_ROOT/cdl"){
    if(-d "$LAPS_SRC_ROOT/data/cdl") {
	run_sys::run_sys("cp -r $LAPS_SRC_ROOT/data/cdl $LAPS_DATA_ROOT/cdl");
    }else{
	die "Could not find or create cdl directory in $LAPS_DATA_ROOT/cdl";
    }
}
opendir(CDL_DIR,"$LAPS_DATA_ROOT/cdl");
my @cdl_list = grep /\.cdl$/, readdir CDL_DIR;
closedir CDL_DIR;

foreach(@cdl_list){
#
# DO not edit the model output cdl files, the user must currently edit these by hand.
#
    next if/^f/;
    open(CDL,"$LAPS_DATA_ROOT/cdl/$_");
    my @cdl = <CDL>;
    close(CDL);

    open(CDL,">$LAPS_DATA_ROOT/cdl/$_");
    foreach(@cdl){
	if(/^(\s+)x\s*=/){
	    print CDL "$1x = $xdim,\n" ;
	}elsif(/^(\s+)y\s*=/){
	    print CDL "$1y = $ydim,\n" ;
	}elsif(/^(\s+)z\s*=\s*(\d+)/){
	    if($2>5  && $2!=42){
		print CDL "$1z = $zdim,\n" ;
	    }else{
		print CDL $_ ;
	    }
	}else{
	    print CDL $_;
	}
    }
    close(CDL);
}


run_sys::run_sys("$LAPSROOT/bin/gridgen_model.exe");	

print "gridgen_model.exe complete - building sfc lookup tables\n";

run_sys::run_sys("$LAPSROOT/bin/gensfclut.exe");

#
# Generate new vrc lookup tables
#

if(-x "$LAPSROOT/bin/genvrclut.exe"){
  print "Running $LAPSROOT/bin/genvrclut.exe with stdout to $LAPS_DATA_ROOT/log/genvrclut.log\n";
  print "This could take an hour or more...\n" unless($sattype eq "wfo"); 
  run_sys::run_sys("$LAPSROOT/bin/genvrclut.exe 1> $LAPS_DATA_ROOT/log/genvrclut.log 2>&1");
}else{
  print "$0 Failed to make genvrclut.exe, check $LAPS_SRC_ROOT/src/ingest/radar/wsiremap/vrc/table/make.out\n";
  exit -1;
}  


#
# Clean out any pre-existing radar remapper look-up tables
#
print "cleaning out static/vxx directory of any old luts\n";
run_sys::run_sys("rm -f $LAPS_DATA_ROOT/static/vxx/*lut*");
print "cleaning out static/lvd directory of any old luts\n";
run_sys::run_sys("rm -f $LAPS_DATA_ROOT/static/lvd/*.lut");

#
# finally initialize the systime.dat file
#
run_sys::run_sys("$LAPSROOT/bin/systime.exe");
print "$0 complete\n";


sub update_nl{
    my($srcroot,$dataroot) = @_;
#
# open and compare nest7grid.parms and *.nl in $srcroot/static and $dataroot/static
# Add variables and files found in $srcroot/static but not $dataroot/static 
# Retain the values of variables found in $dataroot/static for variables in both files
#
# First find all of the variable values in $dataroot/static
#

    opendir(TDIR,"$dataroot/static");
    my @nl = grep(/\.nl$/,readdir(TDIR));
    closedir(TDIR);
    push(@nl,"nest7grid.parms");

    my %nl_vals;
    my(%comments);
    my $nl_file;

    foreach $nl_file (@nl){
	print "First pass of namelist parser $nl_file\n";
	open(FILE,"$dataroot/static/$nl_file");
	my @template = <FILE>;
	close(FILE);

	my $var='';
	my $mark=0;
	my $line;
	foreach $line (@template){
	    if($line =~ /^\s*\&/){
		$mark=1;
		next;
	    }elsif($line =~ /^\s*\//){
		$mark=2;
		next;
	    }elsif($line =~ /^[!cC]/){
		$comments{$nl_file} .= $line;
		$mark=3;
		next;
	    }elsif($line =~ /^\s*(\S+)\s*=\s*(.*)$/){
		$var = $1;
                $var =~ tr/a-z/A-Z/;
		$nl_vals{$var} = $2;
		next;
	    }elsif($line =~ /^(.*)$/){
		$nl_vals{$var} .= "\n$1";
	    }
	    if($mark>0){
		$var = '';
		$mark=0;
	    }
	}

        run_sys::run_sys("cp $dataroot/static/$nl_file $dataroot/static/$nl_file.bak");
    }
    
    opendir(TDIR,"$srcroot/static");
    my @nnl = grep(/\.nl$/,readdir(TDIR));
    closedir(TDIR);
    push(@nnl,"nest7grid.parms");
    
    foreach $nl_file (@nnl){
	open(INFILE,"$srcroot/static/$nl_file");
	my @infile = <INFILE>;
	close(INFILE);
	
	print "merging $srcroot/static/$nl_file into $dataroot/static/$nl_file\n";
	open(OUTFILE,">$dataroot/static/$nl_file") or die "Could not open $dataroot/static/$nl_file to write";
        my($var, $val, $line, $eon);

 	my @comments = split("\n",$comments{$nl_file});

	foreach $line (@infile){
            next if($line eq "\n");
#            print ">$line< ".length($line)."\n";
	    if($line =~ /^\s*\//){
		print "End of namelist found\n";
		$eon = 1;
		next;
	    }
	    
	    if($line =~ /^\s*(\S+)\s*=\s*(.*)$/){
		$var = $1;
                
                $var =~ tr/a-z/A-Z/;
		$val = $2;
		if(exists $nl_vals{$var}){
#                    print "Found $var = $val\n";
		    $val = $nl_vals{$var};
		}
                $val =~ s/\n$//;
		print OUTFILE " $var = $val\n";
		next;
            }elsif($line =~ /^[!cC]/){
		chomp($line);
		my $tmpline = $line;
		$tmpline =~ s/[(\[\]\\\/\(\)\!\$\^)]/\$1/g;
                next if(grep(/$tmpline/,@comments)>0);
		push(@comments,$line);
		next;
#		print OUTFILE $line;		;
            }elsif($line =~ /^\s*&/){
		print OUTFILE $line;
		next;
	    }elsif(($line =~ /^(\s*[^&\/].*)$/) && exists $nl_vals{$var}){
		next;
	    }
	    print OUTFILE $line;

	}
	print OUTFILE " \/\n";
	foreach(@comments){
	    print OUTFILE "$_\n";
	}
	close(OUTFILE);
    }

}


sub safe_cp{
    my($indir,$outdir) = @_;
    
    opendir(INDIR,$indir);
    my(@files) = grep !/^\.\.?$/,readdir INDIR;
    close(INDIR);
    my $file;   
    foreach $file (@files){
        next if($file =~ /^CVS$/);
	next if($file =~ /^\#/);
	next if($file =~ /~$/);

	if(-d "$indir/$file"){
	    if(-d "$outdir/$file") {
		&safe_cp("$indir/$file","$outdir/$file");
	    }else{
                print "Copying Directory $indir/$file to $outdir/$file\n";
		run_sys::run_sys("cp -r $indir/$file $outdir/$file");
	    }
	    next;
	}
	next if(-e "$outdir/$file");
        print "Copying file $indir/$file to $outdir/$file\n";
	run_sys::run_sys("cp $indir/$file $outdir/$file");
    }	
}

sub wfo_localization{
  my($LAPS_SRC_ROOT,$LAPSROOT,$LAPS_DATA_ROOT,$FXA_DATA,$satid) = @_;
  my($root) = $ENV{"FXA_LOCALIZATION_ROOT"};
  my($site) = $ENV{"FXA_INGEST_SITE"};
  my($file1) = "$ENV{FXA_HOME}/data/localizationDataSets/$ENV{FXA_LOCAL_SITE}/whichSat.txt";
  my($file2) = "$root/$site/Laps_Center_Point.txt";
  my($goes) = 0;
  my($lat,$lon);  

  open(LOCFILE,$file2) or die "Can't find $file2.";
  my $line = <LOCFILE>;
  chop($line);
  $line =~ s/ +/,/;
  ($lat,$lon) = split(",",$line);

  if($satid eq "g8"){
      $goes = 8;
  }elsif($satid eq "g9"){
      $goes = 9;
  }elsif(-r $file1){
      open(LOCFILE,$file1) or die "Can't find $file1.";
      my $line = <LOCFILE>;
      close(LOCFILE);
      $goes=9 if($line =~ /WEST/i);      
      $goes=8 if($line =~ /EAST/i);      
  }else{
      $goes = $lon>-100 ? 8:9;  # identifies the goes sat to use based on longitude
  }
  #First files:  the namelist files.


  opendir(NL,"$LAPS_DATA_ROOT/static");
  my(@templates) = grep(/\.nl/,readdir(NL));
  closedir(NL);
  push(@templates,"nest7grid.parms");
  my $template;
  foreach $template (@templates){
      $template = "$LAPS_DATA_ROOT/static/$template";

      open(TEMPLATE,"$template") or die "$0: Can't find template file in $template";
      my @template = <TEMPLATE>;
      close(TEMPLATE);
      print "Using static template file $template\n";

      my $i;

      for($i=0;$i<=$#template;){
        if ($template[$i] =~ /=/){
            $i++;
            next;
        }
        if ($template[$i] =~ /^\s*\&/){
            $i++;
            next;
        }
        last if ($template[$i] =~ /^\s*\//);
        
        $template[$i-1]=join('',$template[$i-1],$template[$i]);
        splice(@template,$i,1);
      }


      open(OUTFILE,">$template") or die "$0: Can't open $template to write";
      
      foreach (@template)
      {
	  $_ =~ s/\$FXA_DATA/$FXA_DATA/;
	  if(/standard_latitude\s*=/){
	      print OUTFILE " standard_latitude=$lat,\n";
	  }elsif(/standard_longitude\s*=/){
	      print OUTFILE " standard_longitude=$lon,\n";
	  }elsif(/grid_cen_lat_cmn\s*=/){
	      print OUTFILE " grid_cen_lat_cmn=$lat,\n";
	  }elsif(/grid_cen_lon_cmn\s*=/){
	      print OUTFILE " grid_cen_lon_cmn=$lon,\n";
	  }elsif(/\sISATS\s*=/){
	      if($goes==8){
		  print OUTFILE " ISATS = 1,0,0,\n";
	      }else{
		  print OUTFILE " ISATS = 0,1,0,\n";
	      }
	      
          }elsif(/\sgoes_switch\s*=/){
	      print OUTFILE " goes_switch = $goes,\n";
	  }elsif(/\sITYPES\s*=/){
	      if($goes==8){
		  print OUTFILE " ITYPES = 0,1,0,0,0,0,0,0,0,0,0,0,\n";
	      }else{
		  print OUTFILE " ITYPES = 0,0,0,0,0,1,0,0,0,0,0,0,\n";
	      }

	  }else{
	      print OUTFILE $_;
	  }
      }
      close(OUTFILE); 
  }

  $goes = "g".$goes;


}
