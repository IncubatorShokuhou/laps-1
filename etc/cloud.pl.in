#!@PERL@
# @configure_input@

# Looks in logdir (from command line) or $LAPS_DATA_ROOT/log.
# The other command line argument is the hour of the LAPS run
# if not current.  Both command line arguments are optional;
# order doesn't matter.

$nargs = @ARGV;
if ($nargs == 0) {}
elsif ($nargs == 1) {
 $arg = shift;
 if ($arg =~ /^[0-9]*$/) {$hr=$arg;}
 else {$logdir = $arg;}
 }
elsif ($nargs == 2) {
 $arg1 = shift;
 $arg2 = shift;
 if ($arg1 =~ /^[0-9]*$/) {$hr=$arg1; $logdir=$arg2;}
 else {$hr=$arg2; $logdir=$arg1;}
 }
 
$LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};

if (defined $logdir) {if ($logdir eq $LAPS_DATA_ROOT) {$logdir=$logdir."/log";} }
elsif (defined $LAPS_DATA_ROOT) {$logdir=$LAPS_DATA_ROOT."/log";}
else {die "Can't find path to log data.\n";}

if (defined $hr) {$hr="0".$hr if (length($hr)<2);}

# Get the most recent log file.

$logname = "cloud";
@filenames = <$logdir/$logname.log*>;
$nfiles = @filenames;
if ($nfiles == 0) {die "No log files found.\n"}
$age_of_newest = 1;
foreach $file (@filenames) {
  $age = -M $file;
  if ($age < $age_of_newest) {
    $filename = $file;
    $age_of_newest = $age; } }

# This is a bit more kosher...
if (defined $hr) { 
    if(length($hr) < 4)
       {$filename = $logdir."/".$logname.".log.".$hr."20";}
    else
       {$filename = $logdir."/".$logname.".log.".$hr;}
}

open(FILE,$filename) or die "Can't open $filename.";
@lines = <FILE>;
print "\nReading from log file $filename\n\n";

# See if the analysis is done.
#@greplines = grep /End of Cloud Analysis Package/, @lines;
#$ngreplines = @greplines;
#if ($ngreplines == 0) {print "Cloud analysis isn't finished.\n";}

# Determine background model.

$modeltype = "missing";
$searchstring = "Successfully obtained: ";
foreach (@lines) {
  if (/$searchstring(.*)/) {
    ($modeltime,$modeltype,$modelfield) = split(" ",$1,$2); 
    last; } }
if ($modeltype eq "missing") {print "Can't determine model background.\n"}
print "BACKGROUND $modelfield FIELD:  ";

if ($modeltype =~ /ram/) {
  if ($modeltime =~ /(\d\d\d\d\d)(\d\d\d\d)(\d\d\d\d)/ ) {
    $runtime = $2+0;
    $fcsthr = $3/100;
    print "Using $fcsthr hr fcst from local model started at $runtime UTC \n";
    print "(local model file timestamp = $modeltime)\n"; } } 
else {
  $bgmodelfile = $filename;
  $bgmodelfile =~ s/$logname/lga/;
  open(BGMODEL,$bgmodelfile) or die "Can't open $bgmodelfile.";
  foreach (<BGMODEL>) {
    if (/cmodel (\w*)/) {$modelid = $1;}
    if (/Reading - (.*)/) {$pathname = $1; last; close BGMODEL; } 
    if (/reading cdfname\: (.*)/) {$pathname = $1; last; close BGMODEL; } }
  $basename = $1 if ($pathname =~ /([^\/]*)$/);
  if ($basename =~ /(\d\d\d\d\d)(\d\d\d\d)(\d\d)(\d\d)/) {
    $runtime = $2/100;
    $fcsthr = $4;
    print "Using $fcsthr hr fcst from $modelid started at $runtime UTC \n"; } 
  elsif ($basename =~ /(\d\d\d\d)(\d\d)(\d\d)\_(\d\d)(\d\d)/) {
    $runtime = $4;
    print "Using grids from $modelid started at $runtime UTC \n"; }
  else {
    print "$modelid (Sorry -- can't decode model filename)\n"; } }

# Temp/hgt info
print "\nLAPS temperature/height fields:\n";
$searchstring = " Reading 3D ";
foreach (@lines) {if (/$searchstring(.*)/) {print "$1\n";}}

# Satellite data
print "\nSatellite (IR):";
@greplines = grep /Returning S8A/, @lines;
print "$greplines[0]";
@greplines = grep /required/, @lines;
print "$greplines[0]\n";

print "Satellite (Visible Albedo):\n";
@greplines = grep /Returning ALB/, @lines;
print "$greplines[0]";
@greplines = grep /could not read albedo/, @lines;
print "$greplines[0]";
@greplines = grep /Visible albedo data used/, @lines;
print "$greplines[0]";
print "\n";

# Radar data
print "Radar:\n";
@greplines = grep /NOWRAD/, @lines;
print "$greplines[0]\n";

# Surface metars (sfc.pl has a nicer way of printing these out)
print "METARS:\n";
@greplines = grep /   METAR  /, @lines;
foreach (@greplines) {
  ($name,@junk) = split;
  print "$name ";}
print "\n";
print "\n";

# Pirep data
print "Pilot reports:\n";
$searchstring = "num pireps/num good pireps/cloud layers =";
foreach (@lines) {
  if (/$searchstring(.*)/) {
   ($dummy,$npireps,$ngood,$nlayers) = split /\s+/, $1;
   print "  $npireps pireps\n";
   print "  $ngood good reports\n";
   print "  $nlayers layers\n";
  }
}
