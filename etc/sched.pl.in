#!@PERL@
# @confiure_input@
# Run the LAPS suite of programs 
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#

use strict;

umask 002;
my $cycle_time = 3600;
my $initial_time = time();
#
# List here the laps products to be executed in the order that they should 
# be executed.
#

my @LAPS_EXE = qw(lga.exe obs_driver.x 
                  ingest_raob.exe 
                  ingest_cloud_drift.exe ingest_pireps.exe ingest_acars.exe 
                  ingest_pro.exe ingest_blppro.exe ingest_vad.exe
		  wind.exe 
                  ingest_lrs.exe ingest_blplrs.exe 
                  laps_sfc.x temp.exe 
                  lvd_sat_ingest.exe cloud.exe lq3driver.x deriv.exe accum.exe  
		  lsm5.exe ingest_lsr_tiros.exe);

my $LAPSROOT=shift || die "LAPS root directory required\n";
require "$LAPSROOT/etc/fxa.pm";

$ENV{PATH}.=":@NETCDFBIN@";

my $fxa_sys =  &Get_env'fxa; #'

$ENV{LAPS_DATA_ROOT} = shift ;
$ENV{LAPS_DATA_ROOT} = "$LAPSROOT/data" if ! $ENV{LAPS_DATA_ROOT};
my $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};
#
#  The second argument is the time delay in hours to 
#  set the systime.dat file, if you're data arrives more than 1 hour 
#  behind it's valid time set this variable to delay the laps cycle.
#
&systime($LAPS_DATA_ROOT,0);
#
# This sends the stdout to the run log file
#
my $hh = (gmtime)[2];
my $mm = (gmtime)[1];
my $hhmm = 100*$hh+$mm;
$hhmm = "0".$hhmm while(length($hhmm)<4);
my($LAPS_LOG_PATH);
if($fxa_sys!=0){
    $LAPS_LOG_PATH = &Set_logdir'fxa; #'
}else{
    $LAPS_LOG_PATH = "$LAPS_DATA_ROOT/log";
}


open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
open(STDOUT, ">$LAPS_LOG_PATH/sched.log.$hhmm") || die "Can't redirect stdout";
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;


my(@locks);
opendir(LOCKDIR,"$LAPS_LOG_PATH");
@locks = grep /^\.locklaps/, readdir(LOCKDIR);
closedir(LOCKDIR);


foreach(@locks){
    $_ =~ /^\.locklaps\.(\d+)$/;
    my $jpid = $1;
    print "WARNING Found LOCK file for sched.pl with pid $jpid - killing previous job\n";
    kill 9,$jpid;
    unlink "$LAPS_LOG_PATH/$_";
}

my $lockfile = "$LAPS_LOG_PATH/\.locklaps\.$$";
open(LOCK,">$lockfile");
close(LOCK);



my $t=gmtime(); print $t." Running purger\n";
system("@PERL@ $LAPSROOT/etc/purger.pl $LAPS_DATA_ROOT/lapsprd");
open(LOG,">>$LAPS_LOG_PATH/runtime.log");
my($exe);
foreach $exe (@LAPS_EXE){
    $t=gmtime(); 
    my $log = $exe;
    $log =~ s/\..*$/\.log\.$hhmm/;
    if(-x  "$LAPSROOT/bin/$exe"){
	print $t." Running $exe\n";
	system("$LAPSROOT/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1");
    }else{
	print $t."WARNING: $exe not found\n";
    }
    my $cur_time = time();
    if($cur_time-$initial_time>$cycle_time){
	print "ERROR: Exceeding LAPS cycle time in $0 exiting after $exe\n";
	print LOG "ERROR: Exceeding LAPS cycle time in $0 exiting after $exe\n";
	last;
    }
}

$t = gmtime;

print LOG "$t\n";
close(LOG);


if($fxa_sys!=0){
    print LOG $t." Running wfo postprocessing\n";
    system("@PERL@ $LAPSROOT/etc/wfo_post.pl $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1");
}

unlink "$lockfile";

sub systime{
    use Time::Local;
    my($DATAROOT,$delay) = @_;
    my $ctime = time - $delay*3600;
    my($sec,$min,$hour,$mday,$mon,$year) = gmtime($ctime);
    my @MON = qw(JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC);
    my $CEN = ($year < 70)?20:19;
#
#  This resets to the top of the hour
#
    $min = '00';
    
    $ctime = timegm(0,0,$hour,$mday,$mon,$year);
    my $ftime = $ctime +  315619200;
    $hour = '0'.$hour if(length($hour)<2);

    my $jjj = &julian($year,$mon+1,$mday);
    
    $jjj="0".$jjj while(length($jjj)< 3);
      
    open(TFILE,">$DATAROOT/time/systime.dat");
    print TFILE "  $ftime\n";
    print TFILE " $year$jjj$hour$min\n";
    print TFILE "$hour\n";
    print TFILE "$min\n";
    print TFILE "$mday-$MON[$mon]-$CEN$year $hour$min\n";
    print TFILE "$year$jjj\n";
    close(TFILE);
}

;#
;#+--+------------------------------------------------------------------+
;#
;# &julian: Calculate julian day from year, month, day
;# Arguments: year, month, day
;# Returns: julian day

sub julian {
    my($yr,$mo,$dy) = @_;
 
    my($b,$g,$d,$e,$f,$today,$first_of_year);
    ($yr < 70) ? $yr += 2000 : $yr += 1900;
 
    # Use temporary vars to compute num of days since Oct 1, 1582 to today
    $b = int ( ($mo - 14) / 12 );
    $g = $yr + 4900 + $b;
    $b = $mo - 2 - 12*$b;
 
    $d = int( (1461*($g-100))/4);
    $e = int( (367*$b)/12);
    $f = int( (3*int($g/100))/4);
 
    $today = $d + $e - $f + $dy - 2432076;
 
    # Now compute number of days from Oct 1, 1582 to Jan 1, $yr
    $mo = 1;
    $dy = 1;
    $b = int( ($mo - 14) / 12);
    $g = $yr + 4900 + $b;
    $b = $mo - 2 - 12*$b;
 
    $d = int( (1461*($g-100))/4);
    $e = int( (367*$b)/12);
    $f = int( (3*int($g/100))/4);
 
    $first_of_year = $d + $e - $f + $dy - 2432076;
 
    # Julian day from 1st of year is $today-$first_of_year+1
 
    $today - $first_of_year + 1;
}
