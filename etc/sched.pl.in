#!@PERL@
# @configure_input@
# Run the LAPS suite of programs 
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# This script runs LAPS analyses. The default is for realtime operation.
#
# Command line arguments
#
# -t                   Run for archive time, specified by number of seconds since
#                      Jan 1 1970 at 0000 UTC
#             
# -d                   Delay in hours (lag time or displaced real-time)
#
# -e                   Extend time in hours (allow for long runs beyond cycle time)
#
# -q                   Use QSUB (e.g. on 'jet'), no value is needed
#
# -r -m N              where "N" is the (default) maximum number of files 
#                      to be kept in each product directory by the purger
#
# second to last arg   $LAPSINSTALLROOT, one level above bin directory
#
# last arg             $LAPS_DATA_ROOT, path to data directory
#                      purger (see call to purger.pl)
#
              
use strict;
use English;
use vars qw($opt_d $opt_c $opt_t $opt_r $opt_m $opt_e $opt_q);
use Getopt::Std;

umask 002;
getopts('d:c:t:rm:e:q');

my $initial_time = time();
#
# List here the laps products to be executed in the order that they should 
# be executed.
#

my @LAPS_EXE = qw(lga.exe 
                  ingest_pro.exe obs_driver.x 
                  ingest_sounding.exe 
                  ingest_cloud_drift.exe ingest_aircraft.exe 
		  wind.exe 
                  ingest_lrs.exe lvd_sat_ingest.exe 
                  laps_sfc.x laps_pbl.x temp.exe 
                  cloud.exe lq3driver.x deriv.exe accum.exe  
		  lsm5.exe ingest_lsr_tiros.exe qbalpe.exe dprep.exe);

my $LAPSROOT=shift || die "LAPS root directory required\n";
require "$LAPSROOT/etc/fxa.pm";


my $fxa_sys =  &Get_env'fxa; #'
$ENV{PATH}.=":@NETCDF@/bin";

$ENV{LAPS_DATA_ROOT} = shift ;
$ENV{LAPS_DATA_ROOT} = "$LAPSROOT/data" if ! $ENV{LAPS_DATA_ROOT};
my $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};

my @cycle_time=&parse_namelist("$LAPS_DATA_ROOT/static/nest7grid.parms",'laps_cycle_time_cmn');
$cycle_time[0]=~/^(\d+),/;
my $cycle_time = ($1>0)?$1:3600;
$cycle_time = $opt_c if($opt_c>0);

my $delay_time = 0;
$delay_time = $opt_d if($opt_d > 0);

my $extend_time=0;
$extend_time = $opt_e if($opt_e >0);

my $archive_time = 0;
$archive_time = $opt_t if($opt_t > 0);
#print "$opt_t $archive_time\n";

#
#  The second argument is the time delay in hours to 
#  set the systime.dat file, if you're data arrives more than 1 hour 
#  behind it's valid time set this variable to delay the laps cycle.
#
&systime($LAPS_DATA_ROOT,$delay_time,$cycle_time,$archive_time);
#
# This sends the stdout to the run log file
#
my $hh = (gmtime)[2];
my $mm = (gmtime)[1];
my $hhmm = 100*$hh+$mm;
$hhmm = "0".$hhmm while(length($hhmm)<4);
my($LAPS_LOG_PATH);
if($fxa_sys!=0){
    $LAPS_LOG_PATH = &Set_logdir'fxa; #'
}else{
    $LAPS_LOG_PATH = "$LAPS_DATA_ROOT/log";
}


open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
unless(open(STDOUT, ">$LAPS_LOG_PATH/sched.log.$hhmm"))
{ 
  print "WARNING: $0 Can't redirect stdout\n";
}
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

my $lockfile = "$LAPS_LOG_PATH/\.locklaps\.$$";


my $t=gmtime(); print $t." Running purger\n";
my $sys = "$EXECUTABLE_NAME $LAPSROOT/etc/purger.pl ";
$sys .= "-r " if($opt_r);
$sys .= "-m $opt_m " if($opt_m);
$sys .= " $LAPS_DATA_ROOT/lapsprd";

system($sys);
open(LOG,">>$LAPS_LOG_PATH/runtime.log");
my($nexe);
my($exe);
my($exenext);
my($execount);
my($scriptcount);
my($scriptnext);
my($command);
my($nodes_last);
my($nodes_current);
my($nodes_next);

$nodes_last = 0;
$nodes_next = 1;

$execount = 0;
$scriptcount = 0;

$nexe = @LAPS_EXE;
print "Number of executables = $nexe\n";

foreach $exe (@LAPS_EXE){

    my(@locks);
    opendir(LOCKDIR,"$LAPS_LOG_PATH");
    @locks = grep /^\.locklaps/, readdir(LOCKDIR);
    closedir(LOCKDIR);

    foreach(@locks){
	$_ =~ /^\.locklaps\.(\d+)$/;
	my $jpid = $1;    
	open(LFH,"$LAPS_LOG_PATH/$_");
	my $prevproc = <LFH>;
	close(LFH);
	$prevproc = ~/^(\d+) (.*)$/;
	my $cid = $1;
	$prevproc = $2;
	next unless ($cid>1);	
	print "WARNING Found LOCK file for sched.pl with pid $jpid and child $cid - killing $prevproc\n";
        open(PS,"ps -ef |");
	my @ps = <PS>;
	close(PS);
#
# Kill any children of the child
#
	foreach(@ps){
	    if ($_ =~ /\s+(\d+)\s+$cid\s+/){
		print "Killing process $1\n";
		kill -9,$1;
	    }
	}
#
# Kill the child
#
	kill -9,$cid if($cid>0);
	unlink "$LAPS_LOG_PATH/$_";
    }


    $t=gmtime(); 
    my $log = $exe;
    $log =~ s/\..*$/\.log\.$hhmm/;
    if($opt_q){
#       Set up QSUB so that each process (one or more executables in each) submits the next qsub process at the end
        $execount = $execount + 1;
        $exenext = $execount + 1;
        $nodes_current = 1;

        if($execount < $nexe){ # Not yet at end of the list
            if($nodes_last != $nodes_current){ # of nodes has changed OR we are starting

                if($execount > 1){ # after start
                    print TFILE "  \n";
                    print TFILE "cd $LAPS_LOG_PATH\n";
                    print TFILE "/usr/local/bin/qsub $LAPS_LOG_PATH/run_qsub_$scriptnext.sh 1> $LAPS_LOG_PATH/run_qsub_$scriptcount.log 2>&1\n";
                    print TFILE "  \n";
                    print $t." Closing $LAPS_LOG_PATH/run_qsub_$scriptcount.sh before executable # $execount\n";
                    close(TFILE);
                }

#               Start new qsub script
                $scriptcount = $scriptcount + 1;
                $scriptnext = $scriptcount + 1;

                print $t." Opening $LAPS_LOG_PATH/run_qsub_$scriptcount.sh starting with executable # $execount\n";
                open(TFILE,">$LAPS_LOG_PATH/run_qsub_$scriptcount.sh");
                print TFILE "#!/bin/sh\n";
                print TFILE "#PBS -lnodes=$nodes_current:comp\n";
                print TFILE "  \n";
                print TFILE "export LAPS_DATA_ROOT=$LAPS_DATA_ROOT\n";
#               print TFILE "  \n";
#               print TFILE "date >> $LAPS_LOG_PATH/sched.log.$hhmm\n";
#               print TFILE "  \n";
#               print TFILE "echo 'Running (from qsub) $LAPSROOT/bin/$exe' >> $LAPS_LOG_PATH/sched.log.$hhmm\n";
            }

	}

        print " Adding to $LAPS_LOG_PATH/run_qsub_$scriptcount.sh with executable #/nodes $execount $nodes_current $exe\n";
        print TFILE "  \n";
        print TFILE "$LAPSROOT/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1\n";
       
        if($execount == $nexe){ # Last on the list
            print TFILE "  \n";
            print $t." Closing $LAPS_LOG_PATH/run_qsub_$scriptcount.sh with executable # $execount\n";
            close(TFILE);

            chdir($LAPS_LOG_PATH) || die "could not chdir to $LAPS_LOG_PATH";
            $command = "/usr/local/bin/qsub $LAPS_LOG_PATH/run_qsub_1.sh";
            print "Executing $command\n";
            system("$command");

	}

        $nodes_last = $nodes_current;

    }else{
        if(-x  "$LAPSROOT/bin/$exe"){
            print $t." Running $exe\n";
            my $sys="$LAPSROOT/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1";
            &forksub($sys,$lockfile);
        }else{
	    print $t."WARNING: $exe not found\n";
        }

    }

    my $cur_time = time();
    if($cur_time-$initial_time>($cycle_time-$cycle_time*0.01)+$extend_time*3600){
	print "ERROR: Exceeding LAPS cycle time in $0 exiting after $exe\n";
	print LOG "ERROR: Exceeding LAPS cycle time in $0 exiting after $exe\n";
	last;
    }
}

$t = gmtime;

print LOG "$t\n";



if($fxa_sys!=0){
    print LOG $t." Running wfo postprocessing\n";
    my $sys="$EXECUTABLE_NAME $LAPSROOT/etc/wfo_post.pl $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1";
#    system("/usr/nfs/bin/perl $LAPSROOT/etc/wfo_post.pl $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1");

    &forksub($sys,$lockfile);

}
close(LOG);
#unlink "$lockfile";

sub forksub{
    my($sys,$lockfile) = @_;
  FORK: {      
      my $pid;
      if($pid = fork) {
	  # parent process
	  open(LOCK,">$lockfile");
	  print LOCK "$pid $sys\n";
	  close(LOCK);
	
	  waitpid $pid,0;
	  unlink "$lockfile";	  

      }elsif (defined $pid) { 
	  #child here
	  exec($sys);
	  unlink "$lockfile";
	  exit;
      }elsif ($! =~ /No more process/){
	  # EAGAIN, recoverable fork error
	  sleep 5;
	  redo FORK;
      }else{
	  die "Can't fork: $!\n";
      }
  }
}


sub systime{
    use Time::Local;
    my($DATAROOT,$delay,$cycle_time,$archive_time) = @_;

#   See if -t option was used to pass in archive time in calling routine
    my $ctime = 0;    # Initial declaration outside the scope of the if test
    if($archive_time > 0) {
#       print "Archive data time is being set to a ctime of $archive_time...\n";
        $ctime = $archive_time;
    }else{
#       print "Setting ctime based on clock time and delay of $delay in hours...\n";
        $ctime = time - $delay*3600;
    }

#   print "ctime = $ctime\n";

    my($sec,$min,$hour,$mday,$mon,$year) = gmtime($ctime);
    my $yyyy = 1900+$year;
    my @MON = qw(JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC);
    $year= $year-100 if($year>99);
    $year='0'.$year if(length($year)<2);
    $mday = '0'.$mday if(length($mday)<2);

#
#  This resets to the top of the cycle
#
    my $minute=$min;
    my $i=0;
    while($i<60){
	my $mod = $i%int($cycle_time/60);
	$min = $i if($i<$minute && $mod==0);
	$i++;
	#     print "$i $mod\n";
    }
  
    
    $ctime = timegm(0,$min,$hour,$mday,$mon,$yyyy-1900);

    my $ftime = $ctime +  315619200;
    $min = '0'.$min if(length($min)<2);
    $hour = '0'.$hour if(length($hour)<2);

    my $jjj = &julian($year,$mon+1,$mday);
    
    $jjj="0".$jjj while(length($jjj)< 3);
      
    open(TFILE,">$DATAROOT/time/c_time.dat");
    print TFILE " $year$jjj$hour$min\n";
    print TFILE "   $ctime\n";
    close(TFILE);

    open(TFILE,">$DATAROOT/time/systime.dat");
    print TFILE "  $ftime\n";
    print TFILE " $year$jjj$hour$min\n";
    print TFILE "$hour\n";
    print TFILE "$min\n";
    print TFILE "$mday-$MON[$mon]-$yyyy $hour$min\n";
    print TFILE "$year$jjj\n";
    close(TFILE);
}

;#
;#+--+------------------------------------------------------------------+
;#
;# &julian: Calculate julian day from year, month, day
;# Arguments: year, month, day
;# Returns: julian day

sub julian {
    my($yr,$mo,$dy) = @_;
 
    my($b,$g,$d,$e,$f,$today,$first_of_year);
    $yr = ($yr < 70) ? ($yr + 2000) : ($yr + 1900);
 
    # Use temporary vars to compute num of days since Oct 1, 1582 to today
    $b = int ( ($mo - 14) / 12 );
    $g = $yr + 4900 + $b;
    $b = $mo - 2 - 12*$b;
 
    $d = int( (1461*($g-100))/4);
    $e = int( (367*$b)/12);
    $f = int( (3*int($g/100))/4);
 
    $today = $d + $e - $f + $dy - 2432076;
 
    # Now compute number of days from Oct 1, 1582 to Jan 1, $yr
    $mo = 1;
    $dy = 1;
    $b = int( ($mo - 14) / 12);
    $g = $yr + 4900 + $b;
    $b = $mo - 2 - 12*$b;
 
    $d = int( (1461*($g-100))/4);
    $e = int( (367*$b)/12);
    $f = int( (3*int($g/100))/4);
 
    $first_of_year = $d + $e - $f + $dy - 2432076;
 
    # Julian day from 1st of year is $today-$first_of_year+1
 
    $today - $first_of_year + 1;
}

sub parse_namelist{
    my($namelist,@variables) = @_;
    my(@ans);
    open(NL,$namelist);
    my @nl = <NL>;
    close(NL);
    my $i;
    for($i=0;$i<=$#nl;$i++){
	next if($nl[$i] =~ /^\s*&/);
	next if($nl[$i] =~ /^\s*\//);
	next if($nl[$i] =~ /^[\!c]/i);

	my $j;
	for($j=0;$j<=$#variables;$j++){

#	    print "here $variables[$j] $nl[$i]\n";
            
	    if($nl[$i] =~ /^\s+$variables[$j]\s*=\s*(.*)$/i){
		my $ans = $1;
		$i++;
		while($nl[$i++]=~/^\s*([^=]+)$/){
		    $ans.=$1;
		}
		$i--;
		$ans[$j]=$ans;
	    }
	}	
    }
    return(@ans);
}
