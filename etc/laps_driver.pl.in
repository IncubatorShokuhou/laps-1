#!@PERL@
# @configure_input@
#
# Insures that no more than $plimit  processes with the same name exist(s)  
# exits with a warning to stderr if the limit is exceeded  
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Command line arguments
#
# -q  N                Use QSUB (e.g. on 'jet') where N is the number of nodes
#
# -e  e1,e2,...        Environment variables (if any) to pass into the executable
#
# third to last arg    Executable name
#
# second to last arg   $LAPSINSTALLROOT, one level above bin directory
#
# last arg             $LAPS_DATA_ROOT, path to data directory
#                      purger (see call to purger.pl)
#

use strict;
use vars qw($opt_o $opt_e $opt_q);
use Getopt::Std;

getopts('e:q:');

my $exe = shift || die "Program name and LAPS root directory required";
my $LAPSROOT=shift || die "LAPS root directory required";
require "$LAPSROOT/etc/fxa.pm";
umask 002;
my $fxa_sys =  &Get_env'fxa; #'
$ENV{PATH}.=":@NETCDF@/bin";
$ENV{LAPS_DATA_ROOT} = shift ;
$ENV{LAPS_DATA_ROOT} = "$LAPSROOT/data" if ! $ENV{LAPS_DATA_ROOT};
my $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};

if($opt_e){
    foreach(split(/,/,$opt_e)){
	/^(\w+)=(\w+)$/;
	$ENV{$1} = $2;
    }
}


my($LAPS_LOG_PATH);
if($fxa_sys!=0){
    $LAPS_LOG_PATH = &Set_logdir'fxa; #'
}else{
    $LAPS_LOG_PATH = "$LAPS_DATA_ROOT/log";
}

#
# Make sure the requested program exists
#
unless(-x "$LAPSROOT/bin/$exe"){
    die "Program $LAPSROOT/bin/$exe not found or not executable";
}

my $hh = (gmtime)[2];
my $mm = (gmtime)[1];
my $hhmm = 100*$hh+$mm;
$hhmm = "0".$hhmm while(length($hhmm)<4);
my $log = $exe;
$log =~ s/\..*$/\.log\.$hhmm/;
open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
open(STDOUT, ">$LAPS_LOG_PATH/$log") || die "Can't redirect stdout";
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;
#
# Look for a previous lock for this exe in the log directory
#




my(@locks);
opendir(LOCKDIR,"$LAPS_LOG_PATH");
@locks = grep /^\.lock$exe/, readdir(LOCKDIR);
closedir(LOCKDIR);

foreach(@locks){
    $_ =~ /^\.lock$exe\.(\d+)$/;
    my $jpid = $1;
    open(LFH,"$LAPS_LOG_PATH/$_");
    my $cid = <LFH>;
    close(LFH);
    next unless ($cid>1);
    open(PS,"ps -ef |");
    my @ps = <PS>;
    close(PS);
#
# Kill any children of the child
#
    foreach(@ps){
	if ($_ =~ /\s+(\d+)\s+$cid\s+/){
	    print "Killing process $1\n";
	    kill -9,$1;
	}
    }
#
# Kill the child
#    
    print "WARNING Found LOCK file for $exe with pid $jpid and child $cid - killing process $cid\n";
    kill -9,$cid if($cid>0);
    unlink "$LAPS_LOG_PATH/$_";
}

my $lockfile = "$LAPS_LOG_PATH/\.lock$exe\.$$";
#open(LOCK,">$lockfile");
#close(LOCK);

my $command;
my $t;

if($opt_q){
    print $t." Opening $LAPS_LOG_PATH/run_qsub_$exe.sh starting with executable $exe\n";
    open(TFILE,">$LAPS_LOG_PATH/run_qsub_$exe.sh");
    print TFILE "#!/bin/sh\n";
    print TFILE "#PBS -lnodes=$opt_q:comp\n";
    print TFILE "  \n";
    print TFILE "export LAPS_DATA_ROOT=$LAPS_DATA_ROOT\n";

    print " Adding to $LAPS_LOG_PATH/run_qsub_$exe.sh with executable/nodes $exe $opt_q\n";
    print TFILE "  \n";
    print TFILE "$LAPSROOT/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1\n";

    print TFILE "  \n";
    print $t." Closing $LAPS_LOG_PATH/run_qsub_$exe.sh with executable $exe\n";
    close(TFILE);

    chdir($LAPS_LOG_PATH) || die "could not chdir to $LAPS_LOG_PATH";
    $command = "/usr/local/bin/qsub $LAPS_LOG_PATH/run_qsub_$exe.sh";
    print "Executing $command\n";
    system("$command");

}else{
    my $sys = "$LAPSROOT/bin/$exe ";
#   system($sys);
#   unlink "$lockfile";
    &forksub($sys,$lockfile);

}

exit;

sub forksub{
    my($sys,$lockfile) = @_;
  FORK: {      
      my $pid;
      if($pid = fork) {
	  # parent process
	  open(LOCK,">$lockfile");
	  print LOCK "$pid\n";
	  close(LOCK);
	
	  waitpid $pid,0;
	  unlink "$lockfile";


      }elsif (defined $pid) { 
	  #child here
	  exec($sys);
	  unlink "$lockfile";
	  exit;
      }elsif ($! =~ /No more process/){
	  # EAGAIN, recoverable fork error
	  sleep 5;
	  redo FORK;
      }else{
	  die "Can't fork: $!\n";
      }
  }
}






