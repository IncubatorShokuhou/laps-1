#!@PERL@

# Script to generate lapsplot gifs for HMT domain

use lib "@prefix@/etc"; # Set this to your path for 'laps_tools.pm'
require "laps_tools.pm";                 # supplied in $LAPSINSTALLROOT/etc

require 5;
use strict;

# Setup command line options:
#    -m model (e.g. wrf,arw)
#    -a model configuration (e.g. schultz)
#    -d domain (e.g. dwr)
#    -r laps dataroot
#    -f forecast output interval (hours)
#    -c cycle frequency (hours)
#    -l forecast length (hours)

use vars qw($opt_a $opt_d $opt_r $opt_f $opt_c $opt_l $opt_m);
use Getopt::Std;

getopts('a:d:r:f:c:l:m:');

print "Running followup_fcst.pl...\n";
print "user defined paths\n";
my $domain = $opt_d;
my $model = "$opt_m-$opt_a";
$ENV{LAPSINSTALLROOT}="/usr/nfs/lapb/builds64/laps";
my $dataroot = $opt_r;

my $window;
my $resolution;
my $res_x;
my $res_y;

my ($xhigh,$xlow,$yhigh,$ylow);
my $yhigh_thresh;
my $ylow_thresh;
my $x_hw;
my $y_hw;

# Read grid dimensions
my (@xdim,$xdim);
my (@ydim,$ydim);
my $nl_var;
my $domain_nl = "nest7grid.parms";
if(-e "$dataroot/static/$domain_nl"){
    $nl_var="NX_L";
    @xdim=&laps_tools::get_nl_value($domain_nl,$nl_var,$dataroot);
    $nl_var="NY_L";
    @ydim=&laps_tools::get_nl_value($domain_nl,$nl_var,$dataroot);
    $xdim = $xdim[0];
    $ydim = $ydim[0];
    print "xdim,ydim is $xdim,$ydim<br>\n";
}

# Determine window & resolution for NCAR graphics
my $aspect_ratio = ($xdim-1.0) / ($ydim-1.0);
print "aspect_ratio is $aspect_ratio<br>\n";
my $zoom_safe = 1.0;
my $npix_safe = 730;

$x_hw  = 0.5 / $zoom_safe;
if($aspect_ratio > 1.40){
    $res_y=$npix_safe;
    $res_x=int($res_y*1200./885.);
    $resolution="$res_x"."x"."$res_y";
    $y_hw  = 0.36 / $zoom_safe;
    $ylow_thresh  = 0.14;
    $yhigh_thresh = 0.86;
}elsif($aspect_ratio > 1.192){
    $res_y=$npix_safe;
    $res_x=int($res_y*1056./885.);
    $resolution="$res_x"."x"."$res_y";
    $y_hw  = 0.42 / $zoom_safe;
    $ylow_thresh  = 0.08;
    $yhigh_thresh = 0.92;
}else{
    $res_y=$npix_safe;
    $res_x=$res_y;
    $resolution="$res_x"."x"."$res_y";
    $y_hw  = 0.5 / $zoom_safe;
    $ylow_thresh  = 0.0;
    $yhigh_thresh = 1.0;
}

print "resolution is $resolution<br>\n";

$xlow  = 0.5 - $x_hw;
$xhigh = 0.5 + $x_hw;
$ylow  = 0.5 - $y_hw;
$yhigh = 0.5 + $y_hw;

$window="$xlow:$ylow:$xhigh:$yhigh";
print "window is $window<br>\n";

my $followup = "/usr/nfs/common/lapb/www/followup_fcst.sh $domain $model $dataroot $window $resolution";
#my $followup_fire =  "/usr/nfs/common/lapb/www/followup_fcst_fire.sh $domain $model $dataroot $window $resolution";
#my $followup_ua =  "/usr/nfs/common/lapb/www/followup_fcst_ua.sh $domain $model $dataroot $window $resolution";
my $followup_xsect =  "/usr/nfs/common/lapb/www/followup_fcst_xsect.sh $domain $model $dataroot";

my $w3recent = "/w3/lapb/domains/$domain/fcst2d/$model/recent";
my $purger = "/usr/nfs/common/lapb/www/purge_w3_fcst2d.pl -t 36 $domain $model\n";
my $output_inc = $opt_f;     # Forecast output interval (hours)
my $cycle_freq = $opt_c;     # Cycle frequency in hours
my $timeout = $opt_c*3600;   # Seconds to wait before giving up after starting
my $init_base_hr = 0;        # Earliest cycle each day in GMT hour
my $fcst_len = $opt_l;       # Forecast length (hours)

my $fsf_subdir = "lapsprd/fsf/$opt_m-$opt_a";
my $fua_subdir = "lapsprd/fua/$opt_m-$opt_a";

my $sleep_time = 300; # Number of seconds to sleep between attempts to copy

# END OF USER DEFINED PARAMS

# Call purger
print "call purger\n";
print "$purger\n";
system("$purger");

print "setup fsf/fua pathnames\n";
my $local_fsf = "$dataroot/$fsf_subdir";
my $local_fua = "$dataroot/$fua_subdir";

# Set up cycle to process based on system time (UTC)

print "setup time parameters\n";
#beka my $systime_now = time-3600;
my $systime_now = time;
my $cyc_freq_sec = $cycle_freq * 3600;
my $init_base_sec = $init_base_hr * 3600;
my $remainder = ($systime_now - $init_base_sec) % $cyc_freq_sec;
my $cycle_sec = $systime_now - $remainder;

# Unique to NMM downscale of GFS 60-84.
#$cycle_sec = $cycle_sec + 60*3600;

# Convert the cycle time in seconds to normal parameters

my @monthtxt = qw(JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC);
my ($cycsec,$cycmin,$cychour,$cycmday,$cycmon,$cycyear,$cycwday,$cycyday,
    $cycisdt) = gmtime($cycle_sec);

print "convert time parameters\n";
my $cycyear4 = $cycyear + 1900;
$cycyear = $cycyear - 100;
$cycyear = "0".$cycyear while(length($cycyear)< 2);
$cycyday++;
$cycyday = "0".$cycyday while(length($cycyday)<3);
$cychour = "0".$cychour while(length($cychour)<2);
$cycmin = "0".$cycmin while(length($cycmin)<2);
my $cycmontxt = $monthtxt[$cycmon];
$cycmon++;
$cycmon="0".$cycmon while (length($cycmon)<2);
$cycmday = "0".$cycmday while(length($cycmday)<2);
my $www_time = $cycmday."-".$cycmontxt."-".$cycyear4." ".$cychour.$cycmin;
my $cycle = $cycyear.$cycyday.$cychour."00";

print "Cycle to get: $cycle\n";
print "laps_fsf: $local_fsf\n";
print "laps_fua: $local_fsf\n";

# Create the list of file times we need to get

my $num_files = int($fcst_len/$output_inc)+1;

my $fcsthr = 0;
my @times;
while ($fcsthr <= $fcst_len) {
  $fcsthr = "0".$fcsthr while (length($fcsthr)<2);
  push @times, $cycle.$fcsthr."00";
  $fcsthr = $fcsthr + $output_inc;
}

my @times_new;
my @fsffiles_new;
# Time to start the loop to get all of the files
my $timeaccum = 0; 
my $times_rem = $num_files;
my $arrpos;
my ($remfile, $result);
my $www_flag = 0;
while (($timeaccum < $timeout)and($times_rem > 0)){
  $arrpos = 0;
  @times_new = @times; 
  foreach (@times) {
    if (-e "$local_fsf/$_.fsf" and -e "$local_fua/$_.fua"){
      my $validtime;
      print "Ready to process $_ ... \n" ;
      if (/^\d\d\d\d\d(\d\d)\d\d(\d\d)\d\d$/){
        my $basehr=$1;
        my $fcsthr=$2;
        $validtime = $basehr + $fcsthr;
        if ($validtime > 24) {$validtime = $validtime % 24 }
        $validtime = "0".$validtime while (length($validtime)<2);
        $validtime = $validtime."00";
      }
      $result=system("$followup $_ $validtime");
#      $result=system("$followup_fire $_ $validtime");
#      $result=system("$followup_ua $_ $validtime");
      $result=system("$followup_xsect $_ $validtime");
      system("rm -f $local_fsf/$_.fsf.done");
#      system("rm -f $local_fua/$_.fua.done"); 
     if (! $www_flag){
        open(ST, ">$w3recent/systime.dat");
        print ST "$www_time\n";
        close (ST);
        $www_flag =1;
      }
      print "done.\n";
      splice @times_new, $arrpos, 1;
      $timeaccum = 0;
    }else{
       print "Not ready (both fua and fsf). $local_fsf/$_.fsf\n";
       $arrpos++;
    }
  }
  @times = @times_new;
  $times_rem = @times;

  my $t=gmtime(); 

  if ($times_rem > 0){
    print "Sleeping for $sleep_time\n";
    sleep $sleep_time;
    $timeaccum = $timeaccum + $sleep_time;
    print $t." Total time since beginning of loop: $timeaccum\n";  
  }else{
    print "All fua/fsf files processed\n";
  }
}
exit;  
