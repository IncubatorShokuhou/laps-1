#!@PERL@
# @configure_input@
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
use strict;
use English;
use vars qw($opt_r $opt_t $opt_m);
use Getopt::Std;

getopts('rt:m:');


my $DATAROOT=shift || die "LAPS_DATA_ROOT required";

# This script purgers old data files in directories under the lapsprd 
# directory.  It expects the at least the first two characters of the file
# name are digits.  hist_time is the age in days of the oldest files to keep.
# Exceptions can be listed below.
#
my(%clean_dirs, $hist_time, $min_files);

if($opt_r){
    $hist_time = 0;
    $min_files = ($opt_m)?$opt_m:0;
}else{
    $hist_time = ($opt_t)?$opt_t:1.5;
#
# Don't ever completely empty the directories 
#

    $min_files = ($opt_m)?$opt_m:5;
}
#
# exceptions - overridden if $min_files==0
#
if($min_files>0){
    $clean_dirs{lga} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{lgb} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{ram} = (0.75<$hist_time)?0.75:$hist_time;
    $clean_dirs{rsf} = (0.75<$hist_time)?0.75:$hist_time;

    $clean_dirs{lcv} = 2.1;
    $clean_dirs{l1s} = 2.1;
    $clean_dirs{lm2} = 1.5;

    $clean_dirs{v01} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{v02} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{v03} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{v04} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{'rdr/001/raw'} = 1./12.;

    $clean_dirs{'lvd/goes08'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'lvd/goes09'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'lvd/goes10'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'lvd/gmssat'} = (0.25<$hist_time)?0.25:$hist_time;;

    $clean_dirs{dprep} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'model/output'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'model/varfiles'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'../log'} = 30.0;
}


print "Running $0 for data in $DATAROOT default purge time is $hist_time days \n";
print "Leave a minimum of $min_files in each directory\n";



chdir($DATAROOT) || die "could not chdir to $DATAROOT";
my @subdirs = &dodir('.','.');
foreach (@subdirs){
    next if($_ eq '.');
    $_ =~ s/^\.\///;
    $clean_dirs{$_} = $hist_time if(-d $_  && !$clean_dirs{$_});
}

my($dir);
foreach $dir (keys(%clean_dirs)){
    my(@filelist,$i);
    opendir(DIR,$dir);
    if($dir eq '../log'){
	@filelist = grep(/\d\d$/, readdir(DIR));
    }else{
	@filelist = grep(/^\d\d/, readdir(DIR));
    }
    closedir(DIR);
    print "Purging in $dir\n";
    next if($#filelist < $min_files);
    $i=$#filelist;
    my($file, $age);
    foreach $file (sort @filelist){
        stat("$dir/$file");
        $age = -M _;

#        print "$file $age\n";

        if($age > $clean_dirs{$dir} && $i >= $min_files){
            $i--;
            print "Removing file $dir/$file $age $clean_dirs{$dir}\n";
            system("rm -f $dir/$file") ;
	}         

    }
}

sub dodir {
    my($dir,$pattern,$nlink) = @_;
    my($dev,$ino,$mode,$subcount);
    my(@dirlist);
    ($dev,$ino,$mode,$nlink) = stat('.') unless $nlink;


    opendir(DIR,'.');
    my(@filenames) = readdir(DIR);
    closedir(DIR);

    if($nlink==2){                  # directory with no subs
	for (@filenames){
	    next if(/^[\.]+$/);
#            print $_,"\n";
            if($_ =~ $pattern){
#		print "$dir/$_\n";
		push(@dirlist,$dir);
		last;
	    }
	}
    }else{
	$subcount = $nlink-2;
        my($found)=0;
	for(@filenames) {
	    next if(/^[\.]+$/);
	    my $name = "$dir/$_";
	    if(($_ =~ $pattern) && $found==0){
#		print $name,"\n";
                $found++;
		push(@dirlist,$dir);
		
	    }
	    next if $subcount == 0;

	    ($dev,$ino,$mode,$nlink) = lstat($_);

	    next unless -d _;
	    
	    chdir $_ || die "Can't cd to $name\n";
	    push(@dirlist,&dodir($name,$pattern,$nlink));
	    chdir '..';
	    --$subcount;
	}
    }
    return(@dirlist);
}






