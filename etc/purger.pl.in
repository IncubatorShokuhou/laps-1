#!@PERL@
# @configure_input@
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
use strict;
use English;
use vars qw($opt_r $opt_t $opt_m);
use Getopt::Std;

getopts('rt:m:');


my $DATAROOT=shift || die "LAPS_DATA_ROOT required";

# This script purges old data files in directories under the 'lapsprd' 
# directory.  More generally, it purges one or more levels below the
# input directory, not in the directory itself. It purges only those files
# having primarily digits in the name. $hist_time is the age in days of the 
# oldest files to keep.
#
# Command line arguments::
#
# -m  default maximum number of files to keep in each directory
#
# -t  default maximum time (days) to keep files in each directory
#
# Exceptions can be listed below...
#
my(%clean_dirs, $hist_time, $min_files);

if($opt_r){
    $hist_time = 0;
    $min_files = ($opt_m)?$opt_m:0;
}else{
    $hist_time = ($opt_t)?$opt_t:1.5;
#
# Don't ever completely empty the directories 
#

    $min_files = ($opt_m)?$opt_m:5;
}
#
# exceptions - overridden if $min_files==0
#
if($min_files>0){
    $clean_dirs{lga} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{lgb} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{ram} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{rsf} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{fua} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{fsf} = (0.5<$hist_time)?0.5:$hist_time;

    $clean_dirs{lcv} = 2.1;
    $clean_dirs{l1s} = 2.1;
    $clean_dirs{lm2} = 1.5;
    $clean_dirs{lso} = 1.5;
    $clean_dirs{lwc} = 0.5;

    $clean_dirs{v01} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{v02} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{v03} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{v04} = (0.125<$hist_time)?0.125:$hist_time;
    $clean_dirs{'rdr/001/raw'} = 0.08;

    $clean_dirs{'lvd/goes08'} = (0.5<$hist_time)?0.5:$hist_time;;
    $clean_dirs{'lvd/goes09'} = (0.5<$hist_time)?0.5:$hist_time;;
    $clean_dirs{'lvd/goes10'} = (0.5<$hist_time)?0.5:$hist_time;;
    $clean_dirs{'lvd/gmssat'} = (0.5<$hist_time)?0.5:$hist_time;;

    $clean_dirs{dprep} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'model/output'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'model/varfiles'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'../log'} = 2.0;

    if(open(OVERRIDES,"$DATAROOT/../static/purger.dat")){
      foreach(<OVERRIDES>){
	next if(/^\#/);
	if(/^\s*(\S+)\s+(\S+)\s+(\S+)/){
          my $what =  $1;
	  my $how= lc $2;
	  my $when= $3;
	  if($how eq "min"){
	    $clean_dirs{$what} = $when;
	  }else{
	    $clean_dirs{$what} = ($when<$hist_time)?$when:$hist_time;
	  }
	  print "Setting purge for $what from purger.dat to $clean_dirs{$what}\n";
	}
      }
      close(OVERRIDES);
    }

}


print "Running $0 for data in $DATAROOT default purge time is $hist_time days \n";
print "Leave a minimum of $min_files in each directory\n";



chdir($DATAROOT) || die "could not chdir to $DATAROOT";
my @subdirs = &dodir('.','.');
foreach (@subdirs){
    next if($_ eq '.');
    $_ =~ s/^\.\///;
    $clean_dirs{$_} = $hist_time if(-d $_  && !$clean_dirs{$_});
}

my($dir);
foreach $dir (keys(%clean_dirs)){
    my(@filelist,@listoffiles,$i,$j);
    opendir(DIR,$dir);
    if($dir eq '../log'){
	@filelist = grep(/\d\d$/, readdir(DIR));
    }else{
	@filelist = grep(/^\d\d/, readdir(DIR));
    }
# since the previous commands will return an empty @filelist array,
# try for other patterns (raw data files) 
    if($#filelist < 0){
        opendir(SUBDIR,"$DATAROOT/$dir");
        @listoffiles = readdir SUBDIR;
        $j==0;
        foreach (@listoffiles){
#          print "listoffiles $_\n";
           if(/^\D+\.\d+/ || /^\D+\d+\./ && ! /^\./ ){
             @filelist[$j] = $_; 
             $j++;
           }
        }
       close(SUBDIR);
    }
    closedir(DIR);
    next unless(-d $dir);
    print "Purging in $dir\n";
    next if($#filelist < $min_files);
    $i=$#filelist;
    my($file, $age);
    foreach $file (sort @filelist){
        stat("$dir/$file");
        $age = -M _;
	next if(-d "$dir/$file");
#        print "$file $age\n";

        if($age > $clean_dirs{$dir} && $i >= $min_files){
            $i--;
            print "Removing file $dir/$file $age $clean_dirs{$dir}\n";
            system("rm -f $dir/$file") ;
	}         

    }
}

sub dodir {
    my($dir,$pattern,$nlink) = @_;
    my($dev,$ino,$mode,$subcount);
    my(@dirlist);
    ($dev,$ino,$mode,$nlink) = stat('.') unless $nlink;


    opendir(DIR,'.');
    my(@filenames) = readdir(DIR);
    closedir(DIR);

    if($nlink==2){                  # directory with no subs
	for (@filenames){
	    next if(/^[\.]+$/);
#            print $_,"\n";
            if($_ =~ $pattern){
#		print "$dir/$_\n";
		push(@dirlist,$dir);
		last;
	    }
	}
    }else{
	$subcount = $nlink-2;
        my($found)=0;
	for(@filenames) {
	    next if(/^[\.]+$/);
	    my $name = "$dir/$_";
	    if(($_ =~ $pattern) && $found==0){
#		print $name,"\n";
                $found++;
		push(@dirlist,$dir);
		
	    }
	    next if $subcount == 0;

	    ($dev,$ino,$mode,$nlink) = lstat($_);

	    next unless -d _;
	    
	    chdir $_ || die "Can't cd to $name\n";
	    push(@dirlist,&dodir($name,$pattern,$nlink));
	    chdir '..';
	    --$subcount;
	}
    }
    return(@dirlist);
}






