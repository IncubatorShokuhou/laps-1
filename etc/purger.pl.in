#!@PERL@
# @configure_input@
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#

$DATAROOT=shift || die "LAPS_DATA_ROOT required";
$realclean='';
$realclean=shift;
# This script purgers old data files in directories under the lapsprd 
# directory.  It expects the at least the first two characters of the file
# name are digits.  hist_time is the age in days of the oldest files to keep.
# Exceptions can be listed below.
#
my(%clean_dirs);

if($realclean eq "FULLPURGE"){
    $hist_time = 0;
    $min_files = 0;
}else{
    $hist_time = 1.5;
    $clean_dirs{lga} = 0.5;
    $clean_dirs{lcv} = 2.1;
    $clean_dirs{l1s} = 2.1;
    $clean_dirs{lm2} = 1.5;
    $clean_dirs{'../log'} = 30.0;
#
# Don't ever completely empty the directories 
#

    $min_files = 5;
}
print "Running $0 for data in $DATAROOT $realclean\n";

chdir($DATAROOT) || die "could not chdir to $DATAROOT";
@subdirs = &dodir('.','.');
foreach (@subdirs){
    next if($_ eq '.');
    $_ =~ s/^\.\///;
    $clean_dirs{$_} = $hist_time if(-d $_  && !$clean_dirs{$_});
}


foreach $dir (keys(%clean_dirs)){
    opendir(DIR,$dir);
    if($dir eq '../log'){
	@filelist = grep(/\d\d$/, readdir(DIR));
    }else{
	@filelist = grep(/^\d\d/, readdir(DIR));
    }
    closedir(DIR);
    print "Purging in $dir\n";
    next if($#filelist < $min_files);
    $i=$#filelist;
    foreach $file (sort @filelist){
        stat("$dir/$file");
        $age = -M _;

#        print "$file $age\n";

        if($age > $clean_dirs{$dir} && $i >= $min_files){
            $i--;
            print "Removing file $dir/$file $age $clean_dirs{$dir}\n";
            system("rm -f $dir/$file") ;
	}         

    }
}

sub dodir {
    my($dir,$pattern,$nlink) = @_;
    my($dev,$ino,$mode,$subcount);
    my(@dirlist);
    ($dev,$ino,$mode,$nlink) = stat('.') unless $nlink;


    opendir(DIR,'.');
    my(@filenames) = readdir(DIR);
    closedir(DIR);

    if($nlink==2){                  # directory with no subs
	for (@filenames){
	    next if(/^[\.]+$/);
#            print $_,"\n";
            if($_ =~ $pattern){
#		print "$dir/$_\n";
		push(@dirlist,$dir);
		last;
	    }
	}
    }else{
	$subcount = $nlink-2;
        my($found)=0;
	for(@filenames) {
	    next if(/^[\.]+$/);
	    $name = "$dir/$_";
	    if(($_ =~ $pattern) && $found==0){
#		print $name,"\n";
                $found++;
		push(@dirlist,$dir);
		
	    }
	    next if $subcount == 0;

	    ($dev,$ino,$mode,$nlink) = lstat($_);

	    next unless -d _;
	    
	    chdir $_ || die "Can't cd to $name\n";
	    push(@dirlist,&dodir($name,$pattern,$nlink));
	    chdir '..';
	    --$subcount;
	}
    }
    return(@dirlist);
}






