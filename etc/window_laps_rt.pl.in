#!@PERL@
#
#
#Program either localizes (new) or re-localizes (existing)
#laps domains
#J.Smart 8-20-99
#
use strict;
use English;
use vars qw($opt_s $opt_i $opt_d $opt_t $opt_c $opt_m);
use Getopt::Std;
use File::Copy 'cp';

getopts('s:i:d:t:mc');

umask 002;

# --------------- Notes for command line inputs -------------------------------
# opt_s is LAPS_SRC_ROOT override
# opt_i is LAPSINSTALLROOT override
# opt_d is LAPS_DATA_ROOT (eg., /data/lapb/parallel/laps/data) override.
#       if the data root does not exist, then it is created.
#
# opt_t is template subdirectory (eg., /usr/nfs/common/lapb/parallel/laps/template/"name")
#       The name should be the same as the domain name in LAPS_DATA_ROOT
#       If -t is not defined then it is assumed to be the same as
#       LAPS_SRC_ROOT and -c is disabled.
#
# opt_c controls the removal of entire data root (use command line "-c") or
# saves the log and lapsprd directories          (do not use command line "-c")
#
# opt_m controls laps_localization.pl no_ggm switch. ggm = gridgen_model.
#       if $opt_m is not defined then laps_localization updates the namelists
#       and also runs gridgen_model (producing static.nest7grid). If $opt_m
#       is defined then only the namelists are updated (no ggm).
#
# In some cases LAPSINSTALLROOT = LAPS_SRC_ROOT. This is made possible
# by perl module mkdatadirs in laps_tools.pm. It removes Makefile dependence.
#
# The -m and -c options cannot be used simultaneously.
# -----------------------------------------------------------------------------

my ($LAPS_SRC_ROOT, $LAPSINSTALLROOT, $LAPS_DATA_ROOT, $DATAROOT, $DOMAIN_NAME);

$LAPS_SRC_ROOT = $opt_s if( $opt_s);
$LAPSINSTALLROOT = $opt_i if( $opt_i);
$LAPS_DATA_ROOT = $opt_d if( $opt_d);

$LAPS_SRC_ROOT = $ENV{LAPS_SRC_ROOT} if( $ENV{LAPS_SRC_ROOT} && !defined $LAPS_SRC_ROOT);
$LAPSINSTALLROOT = $ENV{LAPSINSTALLROOT} if( $ENV{LAPSINSTALLROOT} && !defined $LAPSINSTALLROOT);
$LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT} if( $ENV{LAPS_DATA_ROOT} && !defined $LAPS_DATA_ROOT);

if( !-d $LAPS_SRC_ROOT){
    print "LAPS SRC ROOT does not exist. $LAPS_SRC_ROOT. Exiting.\n";
    exit;
}

$LAPSINSTALLROOT=$LAPS_SRC_ROOT if(! defined($LAPSINSTALLROOT));

if( !-d $LAPSINSTALLROOT){
    print "LAPS INSTALL ROOT does not exist. $LAPSINSTALLROOT. Exiting.\n";
    exit;
}

my $all_roots_equal = "F";
if(! defined($LAPS_DATA_ROOT) ){$LAPS_DATA_ROOT = "$LAPSINSTALLROOT/data";
   if($LAPS_SRC_ROOT eq $LAPSINSTALLROOT){
      $all_roots_equal = "T";
      print "WARNING: All lapsroots are equal\n";
   }
}

require "$LAPSINSTALLROOT/etc/laps_tools.pm";
$DOMAIN_NAME = &laps_tools::laps_domain_name($LAPS_DATA_ROOT);
$DATAROOT = &laps_tools::laps_data_root($LAPS_DATA_ROOT);

print "\n";

if($LAPS_SRC_ROOT eq $LAPSINSTALLROOT && $all_roots_equal ne "T"){
   my $strlen=length($DATAROOT);
   $DATAROOT = substr($DATAROOT,0,$strlen-1) if(substr($DATAROOT,$strlen,$strlen) eq "/");
   if("$DATAROOT"."$DOMAIN_NAME" eq $LAPS_SRC_ROOT){
      $all_roots_equal = "T";
      print "WARNING: All lapsroots are equal\n";
   }
}

if($all_roots_equal eq "T"){
   if($LAPS_SRC_ROOT eq "/usr/nfs/common/lapb/parallel/laps"){
      print "Re-localizing FSL-LAPS development area is not allowed\n";
      print "\n";
      print "Laps Src Root  = $LAPS_SRC_ROOT\n";
      print "Install_Root   = $LAPSINSTALLROOT \n";
      print "Laps_Data_Root = $LAPS_DATA_ROOT\n";
      exit;
   }
}

my ($LAPS_TEMPLATE, $CONFIG_DOMAIN);

if($opt_t){
   $LAPS_TEMPLATE = $opt_t;
   if(!-e $LAPS_TEMPLATE){
       print "Error: the template directory you specified does not exist.\n";
       print "Terminating.\n";exit;
   }
}else{
   print "WARNING! no -t (path to template) command line input.\n";
   print "Using LAPS_SRC_ROOT (repository) for namelists\n";
}
if($opt_c){
   $CONFIG_DOMAIN = "true";
}else{
#   print "-c command line not specified. Default set to false \n";
   $CONFIG_DOMAIN = "false";
}

print "Laps Src Root  = $LAPS_SRC_ROOT\n";
print "Install_Root   = $LAPSINSTALLROOT \n";
print "Laps_Data_Root = $LAPS_DATA_ROOT\n";
print "Laps Template  = $LAPS_TEMPLATE \n";
print "Config Domain  = $CONFIG_DOMAIN \n";

if($opt_m && $CONFIG_DOMAIN eq "true"){
   print "-m and -c cannot be used simultaneously!\n";
   print " Reconsider the command line inputs.  Abort\n";
   exit;
}

#check to see if any saved static and cdl subdirectories got save to _err; if so, remove.
if( -e "$LAPS_DATA_ROOT/static\_err" ){
   print "removing leftover $LAPS_DATA_ROOT/static\_err\n";
   system("rm -rf $LAPS_DATA_ROOT/static\_err");
}
if( -e "$LAPS_DATA_ROOT/cdl\_err" ){
   print "removing leftover $LAPS_DATA_ROOT/cdl\_err\n";
   system("rm -rf $LAPS_DATA_ROOT/cdl\_err");
}

# WFO: 1st time - save the existing LAPS_DATA_ROOT (in $FXA_LOCAL_DATA/laps_data) before removing it.
#                 softlink data to laps_data appropriately (make "repository" data subdirectory..
#                 otherwise: test if softlink has been broken re-establish it.
if(defined $ENV{FXA_DATA}){
   my $FXA_DATA = $ENV{FXA_DATA};
   my $curdir = Cwd::getcwd();
   chdir "$FXA_DATA/laps";
   my $FXA_LOCAL_DATA = Cwd::getcwd();
   chdir "$curdir";
   chomp $FXA_LOCAL_DATA;
   my $slen=length($FXA_LOCAL_DATA);
   $FXA_LOCAL_DATA = substr($FXA_LOCAL_DATA,0,$slen-5);
   my $LAPS_HOME = $ENV{"LAPS_HOME"};
   if( ! -d "$FXA_LOCAL_DATA/laps_data"){
       mkdir "$FXA_LOCAL_DATA/laps_data", 0777 or die "Can't make directory $FXA_LOCAL_DATA/laps_data";
       system("cp -pr $LAPS_DATA_ROOT/static $FXA_LOCAL_DATA/laps_data/.");
       system("cp -pr $LAPS_DATA_ROOT/cdl $FXA_LOCAL_DATA/laps_data/.");
       system("rm -f $FXA_LOCAL_DATA/laps_data/static/lvd/goes-llij\*.lut");
       system("ln -s $FXA_LOCAL_DATA/laps_data $LAPS_HOME/data");
   }elsif(-e "$LAPS_HOME/data" && ! -l "$LAPS_HOME/data" ){
       print "re-establish softlink $LAPS_HOME/data -> $FXA_LOCAL_DATA/laps_data \n";
       if( -e "$LAPS_HOME/data" ){system("rm -rf $LAPS_HOME/data");}
       system("ln -s $FXA_LOCAL_DATA/laps_data $LAPS_HOME/data");
   }elsif(!-e "$LAPS_HOME/data" ){
       print "re-establish softlink $LAPS_HOME/data -> $FXA_LOCAL_DATA/laps_data \n";
       system("ln -s $FXA_LOCAL_DATA/laps_data $LAPS_HOME/data");
   }
   $LAPS_DATA_ROOT = $FXA_LOCAL_DATA."/laps";
}


if( $CONFIG_DOMAIN eq "true" ) {
  if( $all_roots_equal eq "F" ){

      print "Removing dataroot: $LAPS_DATA_ROOT\n";
      if( -e $LAPS_DATA_ROOT ){
          if( $LAPS_DATA_ROOT ne "/data/lapb/operational/laps/data"||
              $LAPS_DATA_ROOT ne "/data/lapb/parallel/laps/data"){
              system("rm -rf $LAPS_DATA_ROOT");
          }
      } 
      if( !-e "$DATAROOT/$DOMAIN_NAME" ){
          mkdir "$DATAROOT/$DOMAIN_NAME", 0777 or die "Can't make $DATAROOT/DOMAIN_NAME $!\n";
      }

      if( !-e $LAPS_DATA_ROOT ){
         mkdir "$LAPS_DATA_ROOT", 0777 or die "Can't make directory in $LAPS_DATA_ROOT $!\n";
      }
      print "Generate lapsdataroot directory structure\n";
      &laps_tools::mkdatadirs($LAPS_DATA_ROOT);
  }else{
      print "Script will not remove LAPS_DATA_ROOT when all-roots are equal with -c \n";
      print "Reconsider your command line inputs\n";
      exit;}

}else{

  if(-e $LAPS_DATA_ROOT ){
     if($all_roots_equal eq "F") {
        print "Save static and cdl subdirectories\n";
        rename ("$LAPS_DATA_ROOT/static","$LAPS_DATA_ROOT/static\_save");
        rename ("$LAPS_DATA_ROOT/cdl","$LAPS_DATA_ROOT/cdl\_save");
        mkdir "$LAPS_DATA_ROOT/static", 0777 or die "Can't make $LAPS_DATA_ROOT/static $!\n";
        mkdir "$LAPS_DATA_ROOT/cdl", 0777 or die "Can't make $LAPS_DATA_ROOT/cdl $!\n";
     }else{
        print "All lapsroots equal. Make datadirs as necessary\n";
        &laps_tools::mkdatadirs($LAPS_DATA_ROOT);
     }
  }else{
     print "Making a new LAPS_DATA_ROOT.\n";
     mkdir "$DATAROOT/$DOMAIN_NAME", 0777 or die "Can't make $DATAROOT/$DOMAIN_NAME $!\n";
     mkdir "$LAPS_DATA_ROOT", 0777 or die "Can't make $LAPS_DATA_ROOT $!\n";
     &laps_tools::mkdatadirs($LAPS_DATA_ROOT);
  }
}

if( defined($LAPS_TEMPLATE) ){
    if( -e $LAPS_TEMPLATE ){
       if( $all_roots_equal eq "F"){
           print "Copy template namelist files from $LAPS_TEMPLATE to $LAPS_DATA_ROOT/static\n";
           opendir(TEMPDIR, $LAPS_TEMPLATE);
           my @filelist = readdir TEMPDIR;
           closedir TEMPDIR;
           foreach (@filelist){
              if( ! /^\./){
                 system("cp -p $LAPS_TEMPLATE/$_ $LAPS_DATA_ROOT/static");
              }
           }
       }else{
           print "Error: You cannot localize with a template when all LAPS_ROOTS are equal\n";
           exit;
# code below (not tested) will override the above termination and allow the localization!
           print "Save static/cdl in tmpdata. Redefine LAPS_SRC and LAPS_DATA ROOTs.\n";
           mkdir "$LAPS_SRC_ROOT/tmpdata", 0777 or die "Can't make $LAPS_SRC_ROOT/tmpdata $!\n";
           system ("mv $LAPS_DATA_ROOT/static $LAPS_DATA_ROOT/tmpdata/");
           system ("mv $LAPS_SRC_ROOT/cdl $LAPS_SRC_ROOT/tmpdata/");
           $LAPS_SRC_ROOT = $LAPS_SRC_ROOT."/tmpdata"; 
           $LAPS_DATA_ROOT = $LAPS_DATA_ROOT."/tmpdata";
       }
    }else{print "The template subdirectory you specified does not exist: $LAPS_TEMPLATE\n";
          print "Terminating.\n"; exit;}
}else{print "No template subdirectory. All roots equal(?): $all_roots_equal.\n";}

if( -e $LAPSINSTALLROOT ){chdir "$LAPSINSTALLROOT/etc";
    print "Running $LAPSINSTALLROOT/etc/laps_localization.pl\n";
}elsif ( -e "LAPS_SRC_ROOT/etc") {chdir "$LAPS_SRC_ROOT/etc" or die "Can't chdir to LAPS INSTALL or SRC_ROOTs $!\n";
    print "Running $LAPS_SRC_ROOT/etc/laps_localization.pl\n";
}
# ***** Run laps_localization.pl *****
# ------------------------------------
if( $opt_m ){
   print "--no_ggm switch on\n";
   system("@PERL@ ./laps_localization.pl --dataroot=$LAPS_DATA_ROOT --srcroot=$LAPS_SRC_ROOT --lapsroot=$LAPSINSTALLROOT --no_ggm='t' > $LAPS_DATA_ROOT/log/laps_localization.log");
}else{
   system("@PERL@ ./laps_localization.pl --dataroot=$LAPS_DATA_ROOT --srcroot=$LAPS_SRC_ROOT --lapsroot=$LAPSINSTALLROOT > $LAPS_DATA_ROOT/log/laps_localization.log");
}


if( $opt_m ){
    print "restoring gridgen files. Moving from  static_save  to  static \n";
    system ("mv $LAPS_DATA_ROOT/static\_save/topo.dat $LAPS_DATA_ROOT/static/");
    system ("mv $LAPS_DATA_ROOT/static\_save/latlon.dat $LAPS_DATA_ROOT/static/");
    system ("mv $LAPS_DATA_ROOT/static\_save/corners.dat $LAPS_DATA_ROOT/static/");
    system ("mv $LAPS_DATA_ROOT/static\_save/topography.dat $LAPS_DATA_ROOT/static/");
    system ("mv $LAPS_DATA_ROOT/static\_save/static.nest7grid $LAPS_DATA_ROOT/static/");
    system ("mv $LAPS_DATA_ROOT/static\_save/drag_coef.dat $LAPS_DATA_ROOT/static/");
}

print "Checking for static.nest7grid \n";
my $restore_files="false";
if( !-e "$LAPS_DATA_ROOT/static/static.nest7grid"){
    print "$LAPS_DATA_ROOT/static/static.nest7grid does not exist!\n";
    print "Setting variable - restore_files - to true\n";
    $restore_files="true";
}else{
    system ("ls -l $LAPS_DATA_ROOT/static/static.nest7grid");
}

if($restore_files eq "false"){
   print "checking laps_localization.log\n";
   open(LOC,"$LAPS_DATA_ROOT/log/laps_localization.log");
   my @loc=<LOC>;
   close(LOC);

   my $world_topo_warn_lines = 0;
   foreach(@loc){if(/world/i && /warning/i){$world_topo_warn_lines = 1;}}
   my $error_lines = grep /error/i,@loc;
   my $cannot_lines = grep /cannot/i,@loc;

   if($error_lines gt 0){print "Lines with error found in laps_localization.log\n";
                         $restore_files="true";}
   if($cannot_lines gt 0){print "Lines with cannot found in laps_localization.log\n";}
   if($world_topo_warn_lines gt 0){print "Lines with both world_topo and warning found in laps_localization.log\n";}

   system ("ls -l   $LAPS_DATA_ROOT/log/laps_localization.log");
   system ("tail -1 $LAPS_DATA_ROOT/log/laps_localization.log");
}

if( $restore_files eq "true" ) {
    print "restoring saved static and cdl files\n";
    system("mv $LAPS_DATA_ROOT/static $LAPS_DATA_ROOT/static\_err");
    system("mv $LAPS_DATA_ROOT/cdl $LAPS_DATA_ROOT/cdl\_err");
    system("mv $LAPS_DATA_ROOT/static\_save $LAPS_DATA_ROOT/static");
    system("mv $LAPS_DATA_ROOT/cdl\_save    $LAPS_DATA_ROOT/cdl");
    print "update lapsprd - synchronize with repository\n";
    &laps_tools::mkdatadirs($LAPS_DATA_ROOT);
}

if( -e "$LAPS_DATA_ROOT/static\_save"){
    print "removing $LAPS_DATA_ROOT/static\_save\n";
    system("rm -rf $LAPS_DATA_ROOT/static\_save");
}
if( -e "$LAPS_DATA_ROOT/cdl\_save"){
    print "removing $LAPS_DATA_ROOT/cdl\_save\n";
    system("rm -rf $LAPS_DATA_ROOT/cdl\_save");
}

if( -e "$LAPS_DATA_ROOT\tmpdata"){
    system("rm -rf $LAPS_DATA_ROOT/tmpdata");
}

print "window_laps_rt complete\n";
exit;
