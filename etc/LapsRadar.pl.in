#!@PERL@
# @configure_input@
#
# Insures that no more than $plimit  processes with the same name exist(s)  
# exits with a warning to stderr if the limit is exceeded  
#
# Adapted from laps_driver.pl.in, written by James P. Edwards by Linda Wharton
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#

# This script reads binary radar files in AWIPS and writes out netCDF files
#   for LAPS to ingest.  This script should be called with $LAPSROOT following
#   LapsRadar.pl on the command line.  $LAPS_DATA_ROOT may also follow $LAPSROOT
#   on the command line, but is not required if $LAPS_DATA_ROOT is $LAPSROOT/data.
#
# The script determines what radar had been previously been used as a $homeRadar
#   by reading the file extensions in $LAPS_DATA_ROOT/static/vxx.  If no files
#   exist in that directory, $prevRadar is given "none" and the closest radar to
#   the Laps Center Point that is on-line is used.  The closest radar is also 
#   calculated if the $prevRadar is not on line.
#
# Radars are determined to be on-line if they have a current RPS list in
#   $FXA_DATA/radar/lists (indicated by an XXXX.current file, where XXXX is the radar).
#   If $homeRadar is different from the previous radar, the files in 
#   $LAPS_DATA_ROOT/static/vxx are deleted, so new look-up-tables can be generated.
#
# The executable "tfrNarrowband2netCDF" is built in the AWIPS tree, and resides in
#   $FXA_HOME/bin.  It requires 5 command-line parameters to run (see info below)
#
use strict;
use vars qw($opt_o $opt_e $opt_l);
use Getopt::Std;

getopts('e:l');

my $LAPSROOT=shift || die "LAPS root directory required";
require "$LAPSROOT/etc/fxa.pm";
umask 002;
my $fxa_sys =  &Get_env'fxa; #'
$ENV{PATH}.=":@NETCDF@/bin";
$ENV{LAPS_DATA_ROOT} = shift ;
$ENV{LAPS_DATA_ROOT} = "$LAPSROOT/data" if ! $ENV{LAPS_DATA_ROOT};
my $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};

my $sys;
my $lockfile;

if($opt_e){
    foreach(split(/,/,$opt_e)){
	/^(\w+)=(\w+)$/;
	$ENV{$1} = $2;
    }
}

my($LAPS_LOG_PATH);
if(($fxa_sys!=0)and(! $opt_l)){
    $LAPS_LOG_PATH = &Set_logdir'fxa; #'
}else{
    $LAPS_LOG_PATH = "$LAPS_DATA_ROOT/log";
}

my $exe;
my $log;
my $hh = (gmtime)[2];
my $mm = (gmtime)[1];
my $hhmm = 100*$hh+$mm;
$hhmm = "0".$hhmm while(length($hhmm)<4);
$exe = "tfrNarrowband2netCDF";
$log = "LapsRadar\.log\.$hhmm";
open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
open(STDOUT, ">$LAPS_LOG_PATH/$log") || die "Can't redirect stdout";
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;
#=====================================================================
#declare "my" variables
  my $true = 0;
  my $false = 1;
  my $loc;

  my $FXA_HOME = $ENV{FXA_HOME};
  if ($FXA_HOME eq "") {
    $FXA_HOME = "/awips/fxa";
  }

  my $FXA_LOCALIZATION_ROOT = $ENV{FXA_LOCALIZATION_ROOT};
  if ($FXA_LOCALIZATION_ROOT eq "") {
    $FXA_LOCALIZATION_ROOT = "/awips/fxa/data/localizationDataSets";
  }

  my $FXA_INGEST_SITE = $ENV{FXA_INGEST_SITE};
  if ($FXA_INGEST_SITE eq "") {
    $loc = index($LAPS_DATA_ROOT, "KSC");
    if ($loc != -1) {
      $FXA_INGEST_SITE = "ER";
    }    
    $loc = index($LAPS_DATA_ROOT, "VDB");
    if ($loc != -1) {
      $FXA_INGEST_SITE = "WR";
    }    
    if ($FXA_INGEST_SITE eq "") {
      print "Cannot identify Localization from $LAPS_DATA_ROOT...aborting";
      exit;
    }
  }

  my $FXA_DATA = $ENV{FXA_DATA};
  if ($FXA_DATA eq "") {
    $FXA_DATA = "/data/fxa";
  }

  my @oldrad;
  my $name;
  my $value;
  my $homeRadar_U;
  my $homeRadar;
  my $prevRadar;

  my @allrad;
  my @portinfo;
  my @lapsrad;
  my $lapsradCnt;
  my $port;
  my $radNo;
  my $radNo_c;
  my $numrad;

  my @currad;
  my $currName;
  my $currName_U;

  my @avail_radars;
  my $avail_radar;
  my $connect;
  my $num_avail;
  my $num_direct;
  my $radname;
  my @direct;
  my @latlon;
  my $line;
  my $new_radar;
  my @dir_radars;
  my $radno;
  my $numfiles;
  my $dir_open;
  my $curr_avail;
  my @radars;
  my $radar;
  my $lat;
  my $lon;
  my $junk;
  my $junk1;
  my $dist; 
  my $closest;
  my $lat_diff;
  my $lon_diff;
  my @diff;
  my @dir_diff;
  my @sort_diff;
  my $lat_laps;
  my $lon_laps;
  my $found;
  my $found_lat;
  my $found_lon;
  my $min;
  my $loc_min;
  my $radar_selected;

  my $version = 4;  # AWIPS base version number
  my $endWin = time;
  my $startWin = $endWin - 3600;  #look back 1 hour 
  my $yr;
  my $mo;
  my $cmo;
  my $day;
  my $hr;
  my $chr;
  my $cmin;
  my $cday;
  ($junk, $min, $hr, $day, $mo, $yr, $junk, $junk, $junk) = gmtime($startWin);
  $yr += 1900;
  $mo += 1;
  $cmo = sprintf("%02d", $mo);
  $chr = sprintf("%02d", $hr);
  $cmin = sprintf("%02d", $min);
  $cday = sprintf("%02d", $day);
  my $cStartWin = $yr.$cmo.$cday."_".$chr.$cmin;
  print "Start of time window: $cStartWin\n";
  ($junk, $min, $hr, $day, $mo, $yr, $junk, $junk, $junk) = gmtime($endWin);
  $yr += 1900;
  $mo += 1;
  $cmo = sprintf("%02d", $mo);
  $chr = sprintf("%02d", $hr);
  $cmin = sprintf("%02d", $min);
  $cday = sprintf("%02d", $day);
  my $cEndWin = $yr.$cmo.$cday."_".$chr.$cmin;
  print "End of time window: $cEndWin\n";

  my $inputDir;
  my $outputDir = "$LAPS_DATA_ROOT/lapsprd/rdr/001/raw";
#=====================================================================
if($fxa_sys!=0){
#
# PROCESS FXA binary radar files
#
#
# Make sure the requested program exists
#
  unless(-x "/$FXA_HOME/bin/$exe"){
    die "Program $exe not found or not executable";
  }

#
# Look for a previous lock for this exe in the log directory
#

  my(@locks);
  opendir(LOCKDIR,"$LAPS_LOG_PATH");
  @locks = grep /^\.lock$exe/, readdir(LOCKDIR);
  closedir(LOCKDIR);

  foreach(@locks){
    $_ =~ /^\.lock$exe\.(\d+)$/;
    my $jpid = $1;
    open(LFH,"$LAPS_LOG_PATH/$_");
    my $cid = <LFH>;
    close(LFH);
    next unless ($cid>1);
    open(PS,"ps -ef |");
    my @ps = <PS>;
    close(PS);
#
# Kill any children of the child
#
    foreach(@ps){
	if ($_ =~ /\s+(\d+)\s+$cid\s+/){
	    print "Killing process $1\n";
	    kill -9,$1;
	}
    }
#
# Kill the child
#    
    print "WARNING Found LOCK file for $exe with pid $jpid and child $cid - killing process $cid\n";
    kill -9,$cid if($cid>0);
    unlink "$LAPS_LOG_PATH/$_";
  }

  $lockfile = "$LAPS_LOG_PATH/\.lock$exe\.$$";

#=====================================================================
# read file $LAPS_DATA_ROOT/static/vxx/radar.lst to determine $homeRadar and radars LAPS knows about
  open(RADARLST, "$LAPS_DATA_ROOT/static/vxx/radar.lst");
  
  while (<RADARLST>) {
    chomp($_);
    push @lapsrad, $_;
  }
  my $lapsradarNo = scalar(@lapsrad);  # get number of elements in @lapsrad
  close(RADARLST);

  if ($lapsradarNo < 1) { #no radar.lst file, generate file with 10 radars closest to LAPS centerpoint
                          #with the closest being first, and the 10th closest being last in the list

#   open $LAPS_DATA_ROOT/static/nest7grid.parms and read grid_cen_lat_cmn and grid_cen_lon_cmn
    open(LAPSCTR, "$LAPS_DATA_ROOT/static/nest7grid.parms") 
      or die "Can't read $LAPS_DATA_ROOT/static/nest7grid.parms";
    $found_lat = 0;
    $found_lon = 0;
    while (<LAPSCTR>) {
      chomp $_;
      $_ =~ tr/A-Z/a-z/;
      ($name, $value) = split("=");

      $loc = index($name, "grid_cen_lat_cmn");
      if ($loc != -1) {
        $found_lat = 1;
        $lat_laps = $value;
      }       
     
      $loc = index($name, "grid_cen_lon_cmn");
      if ($loc != -1) {
        $found_lon = 1;
        $lon_laps = $value;
      }       
     
      if ($found_lat == 1 && $found_lon == 1) {
        last;
      }
    }
    close(LAPSCTR);

#   open file $FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/Laps_Center_Point.txt and read $lat_laps, $lon_laps
#    open(LAPSCTR, "$FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/Laps_Center_Point.txt") or die "Can't get LAPS Center";
#    while (<LAPSCTR>) {
#      ($lat_laps, $lon_laps) = split(" ");
#    }
#    close(LAPSCTR);

#   open file $FXA_HOME/data/localizationDataSets/$FXA_INGEST_SITE/radarsInUse.txt 
#     to see which radars site has access to 
    open(AVAIL,"$FXA_HOME/data/localizationDataSets/$FXA_INGEST_SITE/radarsInUse.txt") 
      or die "Can't read radarsInUse.txt";
    foreach (<AVAIL>) {
      ($avail_radar, $junk, $connect) = split(" ");
      $avail_radar =~ tr/a-z/A-Z/;
      if ($connect eq "2") {
        push @direct, $avail_radar;
      } else { 
        push @avail_radars, $avail_radar;
      }
    }
    close(AVAIL);
    $num_avail = @avail_radars;

#   open file $FXA_HOME/data/localization/nationalData/radarInfoMaster.txt (contains lat and lon of all radars)
    open(LATLON,"$FXA_HOME/data/localization/nationalData/radarInfoMaster.txt") or die "Can't read radarInfoMaster.txt";
    foreach (<LATLON>) {
      ($new_radar, $lat, $lon, $junk) = split(" ");
      $new_radar =~ tr/a-z/A-Z/;
#     find $new_radar in @avail_radars
      foreach $radname (@avail_radars) {
        if ($radname eq $new_radar) {
          $lat_diff = abs($lat_laps - $lat); 
          $lon_diff = abs($lon_laps - $lon);
          push @radars, $new_radar;
          push @diff, ($lat_diff + $lon_diff);
          last;
        } 
      }

#     find $new_radar in @direct
      foreach $radname (@direct) {
        if ($radname eq $new_radar) {
          $lat_diff = abs($lat_laps - $lat); 
          $lon_diff = abs($lon_laps - $lon);
          push @dir_radars, $new_radar;
          push @dir_diff, ($lat_diff + $lon_diff);
          last;
        } 
      }
    }
    close(LATLON);
    $num_direct = @dir_radars;  #number elements in @dir_radars

# now have @radars and @diff for radars in radarsInUse.txt
# look for closest radar in @direct to use as home radar...it's direct connect
    $min = 999999999.0;
    for ($radno = 0; $radno < $num_direct; $radno++) {
      if ($dir_diff[$radno] < $min) {
        $loc_min = $radno;
        $min = $dir_diff[$radno];
      }
    }

    push @lapsrad, $dir_radars[$loc_min];
    $lapsradCnt = @lapsrad;
    $homeRadar_U = $dir_radars[$loc_min];

#   add rest of radars (if they exist) from dir_radars to @radars
    for ($radno = 0; $radno < $num_direct; $radno++) {
      if ($radno != $loc_min) {
        push @radars, $dir_radars[$radno];
        push @diff, $dir_diff[$radno];
      }
    }

    my $nRadars = 0;
    my $radCnt = @radars;  #number elements in @radars
    my $diffCnt = @diff;   #number of elements in @diff
    if ($radCnt != $diffCnt) {
      print "@radars and @diff have different number of elements!\n";
      print "$LAPS_DATA_ROOT/static/vxx/radar.lst may be corrupt!\n";
    }

    $min = 999999999.0;
    while($lapsradCnt < $radCnt + 1) {
      $loc_min = -1;
      $min = 99999999.0;
      $loc = 0;

      while ($loc < $radCnt) {
        if ($diff[$loc] < $min) {
          $loc_min = $loc;
          $min = $diff[$loc];
        }
        $loc++;
      }
      if ($loc_min != -1) {
        push @lapsrad, $radars[$loc_min];
        $lapsradCnt = @lapsrad;
        $diff[$loc_min] = 999999999.0;
      }
    }  

# write  radars out to file $LAPS_DATA_ROOT/static/vxx/radar.lst 
# @lapsrad should have the radars in radarsInUse.txt ordered by distance from Laps_Center_Point
    open(RADARLST, ">$LAPS_DATA_ROOT/static/vxx/radar.lst");  # open for write 
    foreach (@lapsrad) {
      print RADARLST "$_\n";
    }
    close(RADARLST);

  } 

  $homeRadar_U = @lapsrad[0];
  $homeRadar = $homeRadar_U;
  $homeRadar =~ tr/A-Z/a-z/;
  $lapsradarNo = scalar(@lapsrad);  # get number of elements in @lapsrad

  print "homeRadar_U: $homeRadar_U\n";
  print "Current Radars: @currad \n";

  $radar_selected = 0;
  $curr_avail = 0;
#---------------------------------------------------------------------
# read file ${FXA_LOCALIZATION_ROOT}/${FXA_INGEST_SITE}/portInfo.txt to see what radars on-line
  open(PORTINFO, "$FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/portInfo.txt") or die "Can't open portInfo.txt";
  my $lineNo = 1;
  while (<PORTINFO>) {
    ($junk1, $junk, $junk, $radar) = split(" ");
    if ($junk1 eq "#") {
    }
    else {
      push @portinfo, $radar;
      $lineNo++;
    }
  }
  close(PORTINFO);
  $numrad = scalar(@portinfo);  # get number of elements in @portinfo

  if ($numrad < 1) {
    print "No radars in portInfo.txt\n";
  } else {
    print "Radars on line: @portinfo \n";

#---------------------------------------------------------------------
# Determine which radars have "current" RPS lists 

    opendir(RPS,"$FXA_DATA/radar/lists") or die "Can't open directory $FXA_DATA/radar/lists\n";
    @allrad = readdir(RPS);
    closedir(RPS);

    my $newadd = 0;
    my $status;
    foreach (@portinfo) {
      $port = $_;
      foreach (@allrad) {
        ($currName_U, $status) = split /\./;
        if (($status eq "current") && ($currName_U eq $port)) {
          @currad[$newadd] = $currName_U;
          $newadd += 1;
        }
      }
    }
    $numrad = scalar(@currad);  # get number of elements in @currad

    if ($numrad < 1) {
      print "No radars with current RPS lists to process.\n";
    } else {
      print "Radars available: @currad \n";
      $radar_selected = 1;
    }
  }

#---------------------------------------------------------------------
  if ($version == 4) { 
    $found = $false;
    if ($radar_selected == 1) {  # radars are connected to port
#     see if $homeRadar is on line, if not, choose closest radar to Laps Center
      foreach (@currad) {
        chomp($_);
        if (($homeRadar_U eq $_) && ($found == $false)) {
#         check to see files available and current
          $radar = $_;
          $radar =~ tr/A-Z/a-z/;
          $dir_open = opendir(RADARDIR,"$FXA_DATA/radar/$radar/Z/elev0_5/res2/level16");
          if (! $dir_open) {
            print "Can't open directory $FXA_DATA/radar/$radar/Z/elev0_5/res2/level16\n";
            next;
          } else {
            @allrad = readdir(RADARDIR);
            closedir(RADARDIR);

            $numfiles = 0;
            foreach (@allrad) {
              if ((substr($_,0,1) ne ".") && ($_ =~ /^\d/)) {
                $numfiles++;
              }
            }
            if ($numfiles > 0) {
              $found = $true;
#             see if files are within time window
              foreach (@allrad) {
                if ((substr($_,0,1) ne ".") && ($_ =~ /^\d/)) {
                  if ((substr($_,0,13) ge $cStartWin) &&
                      (substr($_,0,13) le $cEndWin)) {
                    print "File in time window\n";
                    $curr_avail = 1;
                    $#currad = -1;
                    $currad[0] = $homeRadar_U;
                    $radar = $homeRadar_U;
                    last;
                  }
                }
              }
              if ($curr_avail == 1)  {
                last;
              }
            }
          }
        }
      }

      if ($found == $false) {  #$homeRadar is not on line...choose closest on-line radar from @lapsrad
        print "homeRadar is not on line\n";
        for ($radno = 0; $radno < $numrad; $radno++) {
          foreach (@lapsrad) {
            chomp($_);
            if (($currad[$radno] eq $_) &&  ($_ ne $homeRadar_U) && ($found == $false)) {
#             check to see files available and current
              $radar = $_;
              $radar =~ tr/A-Z/a-z/;
              $dir_open = opendir(RADARDIR,"$FXA_DATA/radar/$radar/Z/elev0_5/res2/level16");
              if (! $dir_open) {
                print "Can't open directory $FXA_DATA/radar/$radar/Z/elev0_5/res2/level16\n";
                next;
              } else {
                @allrad = readdir(RADARDIR);
                closedir(RADARDIR);

                $numfiles = 0;
                foreach (@allrad) {
                  print "$radar $_\n";
                  if ((substr($_,0,1) ne ".") && ($_ =~ /^\d/)) {
                    $numfiles++;
                  }
                }
                if ($numfiles > 0) {
#                 see if files are within time window
                  foreach (@allrad) {
                    if ((substr($_,0,1) ne ".") && ($_ =~ /^\d/)) {
                      if ((substr($_,0,13) ge $cStartWin) &&
                          (substr($_,0,13) le $cEndWin)) {
                        print "File in time window\n";
                        $closest = $currad[$radno];
                        $#currad = -1;
                        $closest =~ tr/a-z/A-Z/;
                        $currad[0] = $closest;
                        $radar = $closest;
                        $found = $true;
                        $curr_avail = 1;
                        last;
                      }
                    }
                  }
                  if ($curr_avail == 1) {
                    last;
                  }
                }
              }
            }
          }
        }
      }
    }  # if $radar_selected == 1

    if ($found == $false) {  # no known radars connected via port...check out SBN connections

      foreach (@lapsrad) {
        $radar = $_;
        $radar =~ tr/A-Z/a-z/;
        $dir_open = opendir(RADARDIR,"$FXA_DATA/radar/$radar/Z/elev0_5/res2/level16"); 
        if (! $dir_open) {
          print "Can't open directory $FXA_DATA/radar/$radar/Z/elev0_5/res2/level16\n";
          next;
        } else {
          @allrad = readdir(RADARDIR);
          closedir(RADARDIR);

          $numfiles = 0;
          foreach (@allrad) {
            if ((substr($_,0,1) ne ".") && ($_ =~ /^\d/)) {
              $numfiles++;
            }
          }

          if ($numfiles > 0) {
#           see if files are within time window
            foreach (@allrad) {
              if ((substr($_,0,1) ne ".") && ($_ =~ /^\d/)) {
                if ((substr($_,0,13) ge $cStartWin) &&
                    (substr($_,0,13) le $cEndWin)) {
                  print "File in time window\n";
                  $curr_avail = 1;
                  last;
                }
              }
            }
            if ($curr_avail == 1) {
              $#currad = -1;
              $radar =~ tr/a-z/A-Z/;
              $currad[0] = $radar;
              $radar_selected = 1;
              last;
            }
          }
        }
      }
    }
  }  #if version == 4

#---------------------------------------------------------------------
  if ($radar_selected == 1) {  # radar identified...name is in @currad
    
    $radar =~ tr/A-Z/a-z/;
    $inputDir = "$FXA_DATA/radar/$radar/Z/elev0_5/res2/level16";

    if ($version == 4) {
      $radNo_c = "001";
    } else {
      if ($radNo < 10) {
        $radNo_c = "00".$radNo;
      } elsif ($radNo < 100) {
        $radNo_c = "0".$radNo;
      } else {
        $radNo_c = $radNo."/";
        chop($radNo_c);
      }
    }

    $outputDir = "$LAPS_DATA_ROOT/lapsprd/rdr/$radNo_c/raw";

#---------------------------------------------------------------------
# tfrNarrowband2netCDF requires $radar, $startWin, $endWin, $inputDir, $outputDir on command line
#---------------------------------------------------------------------

    print "Calling parameters:\n";
    print "  radar = $radar\n";
    print "  startWin = $startWin\n";
    print "  endWin = $endWin\n";
    print "  inputDir = $inputDir\n";
    print "  outputDir = $outputDir\n";

    $sys = "$FXA_HOME/bin/$exe $radar $startWin $endWin $inputDir $outputDir";
    &forksub($sys,$lockfile);

#---------------------------------------------------------------------
  
#=====================================================================
#
# run remap_polar_netcdf.exe process
#

    $exe = "remap_polar_netcdf.exe";
    $log = $exe;
    $log =~ s/\..*$/\.log\.$hhmm/;
    open(SAVEOUT,">&STDOUT");
    open(SAVEERR,">&STDERR");
    open(STDOUT, ">$LAPS_LOG_PATH/$log") || die "Can't redirect stdout";
    open(STDERR, ">&STDOUT") || die "Can't dup stdout";
    select(STDERR); $| = 1;
    select(STDOUT); $| = 1;
#
# Make sure the requested program exists
#
    unless(-x "$LAPSROOT/bin/$exe"){
      die "Program $LAPSROOT/bin/$exe not found or not executable";
    }
#
# Look for a previous lock for this exe in the log directory
#

    my(@locks);
    opendir(LOCKDIR,"$LAPS_LOG_PATH");
    @locks = grep /^\.lock$exe/, readdir(LOCKDIR);
    closedir(LOCKDIR);

    foreach(@locks){
      $_ =~ /^\.lock$exe\.(\d+)$/;
      my $jpid = $1;
      open(LFH,"$LAPS_LOG_PATH/$_");
      my $cid = <LFH>;
      close(LFH);
      next unless ($cid>1);
      open(PS,"ps -ef |");
      my @ps = <PS>;
      close(PS);
#
# Kill any children of the child
#
      foreach(@ps){
        if ($_ =~ /\s+(\d+)\s+$cid\s+/){
          print "Killing process $1\n";
          kill -9,$1;
        }
      }
#
# Kill the child
#    
      print "WARNING Found LOCK file for $exe with pid $jpid and child $cid - killing process $cid\n";
      kill -9,$cid if($cid>0);
      unlink "$LAPS_LOG_PATH/$_";
    }

    $lockfile = "$LAPS_LOG_PATH/\.lock$exe\.$$";

    $sys = "$LAPSROOT/bin/$exe ";

    &forksub($sys,$lockfile);

  } else { #if $radar_selected == 1
    print "No radar data available.\n";
  }

  exit;
}

#=====================================================================

sub forksub{
    my($sys,$lockfile) = @_;
  FORK: {      
      my $pid;
      if($pid = fork) {
	  # parent process
	  open(LOCK,">$lockfile");
	  print LOCK "$pid\n";
	  close(LOCK);
	
	  waitpid $pid,0;
	  unlink "$lockfile";


      }elsif (defined $pid) { 
	  #child here
	  exec($sys);
	  unlink "$lockfile";
	  exit;
      }elsif ($! =~ /No more process/){
	  # EAGAIN, recoverable fork error
	  sleep 5;
	  redo FORK;
      }else{
	  die "Can't fork: $!\n";
      }
  }
}






