#!@PERL@
# @configure_input@
#
# Insures that no more than $plimit  processes with the same name exist(s)  
# exits with a warning to stderr if the limit is exceeded  
#
# Adapted from laps_driver.pl.in, written by James P. Edwards by Linda Wharton
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#

# This script reads binary radar files in AWIPS and writes out netCDF files
#   for LAPS to ingest.  This script should be called with $LAPSROOT following
#   LapsRadar.pl on the command line.  $LAPS_DATA_ROOT may also follow $LAPSROOT
#   on the command line, but is not required if $LAPS_DATA_ROOT is $LAPSROOT/data.
#
# The script determines what radar had been previously been used as a $homeRadar
#   by reading the file extensions in $LAPS_DATA_ROOT/static/vxx.  If no files
#   exist in that directory, $prevRadar is given "none" and the closest radar to
#   the Laps Center Point that is on-line is used.  The closest radar is also 
#   calculated if the $prevRadar is not on line.
#
# Radars are determined to be on-line if they have a current RPS list in
#   $FXA_DATA/radar/lists (indicated by an XXXX.current file, where XXXX is the radar).
#   If $homeRadar is different from the previous radar, the files in 
#   $LAPS_DATA_ROOT/static/vxx are deleted, so new look-up-tables can be generated.
#
# The executable "tfrNarrowband2netCDF" is built in the AWIPS tree, and resides in
#   $FXA_HOME/bin.  It requires 5 command-line parameters to run (see info below)
#
use strict;
use vars qw($opt_o $opt_e $opt_l);
use Getopt::Std;

getopts('e:l');

my $LAPSROOT=shift || die "LAPS root directory required";
require "$LAPSROOT/etc/fxa.pm";
umask 002;
my $fxa_sys =  &Get_env'fxa; #'
$ENV{PATH}.=":@NETCDF@/bin";
$ENV{LAPS_DATA_ROOT} = shift ;
$ENV{LAPS_DATA_ROOT} = "$LAPSROOT/data" if ! $ENV{LAPS_DATA_ROOT};
my $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};

my $sys;
my $lockfile;

if($opt_e){
    foreach(split(/,/,$opt_e)){
	/^(\w+)=(\w+)$/;
	$ENV{$1} = $2;
    }
}

my($LAPS_LOG_PATH);
if(($fxa_sys!=0)and(! $opt_l)){
    $LAPS_LOG_PATH = &Set_logdir'fxa; #'
}else{
    $LAPS_LOG_PATH = "$LAPS_DATA_ROOT/log";
}

my $exe;
my $log;
my $hh = (gmtime)[2];
my $mm = (gmtime)[1];
my $hhmm = 100*$hh+$mm;
$hhmm = "0".$hhmm while(length($hhmm)<4);
$exe = "tfrNarrowband2netCDF";
$log = "LapsRadar\.log\.$hhmm";
open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
open(STDOUT, ">$LAPS_LOG_PATH/$log") || die "Can't redirect stdout";
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;
#=====================================================================
#declare "my" variables
  my $true = 0;
  my $false = 1;
  my $FXA_HOME = $ENV{FXA_HOME};

  my $FXA_LOCALIZATION_ROOT = $ENV{FXA_LOCALIZATION_ROOT};
  my $FXA_INGEST_SITE = $ENV{FXA_INGEST_SITE};
  my $FXA_DATA = $ENV{FXA_DATA};

  my @oldrad;
  my $name;
  my $homeRadar_U;
  my $homeRadar;
  my $prevRadar;

  my @allrad;
  my @portinfo;
  my @lapsrad;
  my $port;
  my $radNo;
  my $radNo_c;
  my $numrad;

  my @currad;
  my $currName;
  my $currName_U;

  my @latlon;
  my $line;
  my $radar;
  my $lat;
  my $lon;
  my $junk;
  my $junk1;
  my $closest;
  my $lat_diff;
  my $lon_diff;
  my $lat_laps;
  my $lon_laps;
  my $found;

  my $version = 4;  # AWIPS base version number
  my $endWin = time;
  my $startWin = $endWin - 3600;  #look back 1 hour 
  my $inputDir;
  my $outputDir = "$LAPS_DATA_ROOT/lapsprd/rdr/001/raw";
#=====================================================================
if($fxa_sys!=0){
#
# PROCESS FXA binary radar files
#
#
# Make sure the requested program exists
#
  unless(-x "/$FXA_HOME/bin/$exe"){
    die "Program $exe not found or not executable";
  }

#
# Look for a previous lock for this exe in the log directory
#

  my(@locks);
  opendir(LOCKDIR,"$LAPS_LOG_PATH");
  @locks = grep /^\.lock$exe/, readdir(LOCKDIR);
  closedir(LOCKDIR);

  foreach(@locks){
    $_ =~ /^\.lock$exe\.(\d+)$/;
    my $jpid = $1;
    open(LFH,"$LAPS_LOG_PATH/$_");
    my $cid = <LFH>;
    close(LFH);
    next unless ($cid>1);
    open(PS,"ps -ef |");
    my @ps = <PS>;
    close(PS);
#
# Kill any children of the child
#
    foreach(@ps){
	if ($_ =~ /\s+(\d+)\s+$cid\s+/){
	    print "Killing process $1\n";
	    kill -9,$1;
	}
    }
#
# Kill the child
#    
    print "WARNING Found LOCK file for $exe with pid $jpid and child $cid - killing process $cid\n";
    kill -9,$cid if($cid>0);
    unlink "$LAPS_LOG_PATH/$_";
  }

  $lockfile = "$LAPS_LOG_PATH/\.lock$exe\.$$";

#=====================================================================
# read file ${FXA_LOCALIZATION_ROOT}/${FXA_INGEST_SITE}/portInfo.txt to see what radars on-line
  open(PORTINFO, "$FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/portInfo.txt") or die "Can't open portInfo.txt";
  my $lineNo = 1;
  while (<PORTINFO>) {
    ($junk1, $junk, $junk, $radar) = split(" ");
    if ($junk1 eq "#") {
    }
    else {
      push @portinfo, $radar;
      $lineNo++;
    }
  }
  close(PORTINFO);
  $numrad = scalar(@portinfo);  # get number of elements in @portinfo

  if ($numrad < 1) {
    print "No radars available to process.\n";
    exit;
  } else {
    print "Radars on line: @portinfo \n";
  }

#---------------------------------------------------------------------
# Determine which radars have "current" RPS lists 

  opendir(RPS,"$FXA_DATA/radar/lists") or die "Can't open directory $FXA_DATA/radar/lists\n";
  @allrad = readdir(RPS);
  closedir(RPS);

  my $newadd = 0;
  my $status;
  foreach (@portinfo) {
    $port = $_;
    foreach (@allrad) {
      ($currName_U, $status) = split /\./;
      if (($status eq "current") && ($currName_U eq $port)) {
        @currad[$newadd] = $currName_U;
        $newadd += 1;
      }
    }
  }
  $numrad = scalar(@currad);  # get number of elements in @currad

  if ($numrad < 1) {
    print "No radars with current RPS lists to process.\n";
    exit;
  } else {
    print "Radars available: @currad \n";
  }

#---------------------------------------------------------------------
# read file $LAPS_DATA_ROOT/static/vxx/radar.lst to determine $homeRadar and radars LAPS knows about
  open(RADARLST, "$LAPS_DATA_ROOT/static/vxx/radar.lst");
  
  while (<RADARLST>) {
    chomp($_);
    push @lapsrad, $_;
  }
  my $lapsradarNo = scalar(@lapsrad);  # get number of elements in @lapsrad
  close(RADARLST);
  open(RADARLST, ">>$LAPS_DATA_ROOT/static/vxx/radar.lst");  # open for append

  if ($lapsradarNo < 1) { #no radar.lst file, generate file with radar closest to LAPS centerpoint

#   open file $FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/Laps_Center_Point.txt and read $lat_laps, $lon_laps
    open(LAPSCTR, "$FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/Laps_Center_Point.txt") or die "Can't get LAPS Center";
    while (<LAPSCTR>) {
      ($lat_laps, $lon_laps) = split(" ");
    }
    close(LAPSCTR);

#   open file $FXA_HOME/data/localization/nationalData/radarInfoMaster.txt (contains lat and lon of all radars)
    open(LATLON,"$FXA_HOME/data/localization/nationalData/radarInfoMaster.txt") or die "Can't read radarInfoMaster.txt";
    $lat_diff = 91;
    $lon_diff = 361;
    foreach (<LATLON>) {
      ($radar, $lat, $lon, $junk) = split(" ");
      if ((abs($lat_laps - $lat) <= $lat_diff) && (abs($lon_laps - $lon) <= $lon_diff)) {
        $closest = $radar;
        $lat_diff = abs($lat_laps - $lat);
        $lon_diff = abs($lon_laps - $lon);
      }
    }
    close(LATLON);
    $closest =~ tr/a-z/A-Z/;

# write closest radar out to file $LAPS_DATA_ROOT/static/vxx/radar.lst
    print RADARLST "$closest\n";
    push @lapsrad, $closest;
    $homeRadar_U = $closest;

  } else {  #file radar.lst already exists and @lapsrad is full
    $homeRadar_U = @lapsrad[0];
  }

  $homeRadar = $homeRadar_U;
  $homeRadar =~ tr/A-Z/a-z/;
  $lapsradarNo = scalar(@lapsrad);  # get number of elements in @lapsrad

  print "homeRadar_U: $homeRadar_U\n";
  print "Current Radars: @currad \n";

  $endWin = time;
  $startWin = $endWin - 3600;  #look back 1 hour 

#---------------------------------------------------------------------
  if ($version == 4) { 
#   see if $homeRadar is on line, if not, choose closest radar to Laps Center
    $found = $false;
    foreach (@currad) {
      chomp($_);
      if (($homeRadar_U eq $_) && ($found == $false)) {
        $found = $true;
      }
    }

    if ($found == $false) {  #$homeRadar is not on line...choose closest on-line radar to Laps Center
# open file $FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/Laps_Center_Point.txt and read $lat_laps, $lon_laps
      open(LAPSCTR, "$FXA_LOCALIZATION_ROOT/$FXA_INGEST_SITE/Laps_Center_Point.txt") or die "Can't get LAPS Center";
      while (<LAPSCTR>) {
        ($lat_laps, $lon_laps) = split(" ");
      }
      close(LAPSCTR);

# open file $FXA_HOME/data/localization/nationalData/radarInfoMaster.txt (contains lat and lon of all radars)
      open(LATLON,"$FXA_HOME/data/localization/nationalData/radarInfoMaster.txt") or die "Can't read radarInfoMaster.txt";
      $lat_diff = 91;
      $lon_diff = 361;
      foreach (@currad) {
        chomp($_);
        $currName = $_;
        $currName =~ tr/A-Z/a-z/;
        seek (LATLON, 0, 0);
        while ($line = <LATLON>) {
          ($radar, $lat, $lon, $junk) = split(" ", $line);
          if ($radar eq $currName) {
            if ((abs($lat_laps - $lat) <= $lat_diff) && (abs($lon_laps - $lon) <= $lon_diff)) {
              $closest = $radar;
              $lat_diff = abs($lat_laps - $lat);
              $lon_diff = abs($lon_laps - $lon);
              last;
            }
          }
        }
      }
      close(LATLON);

      if($closest eq ''){
        print "Error finding @currad in $FXA_HOME/data/localization/nationalData/radarInfoMaster.txt\n";
        print "No radar processed.\n";
        exit;
      } else {
        $#currad = -1;
        $closest =~ tr/a-z/A-Z/;
        @currad[0] = $closest;
      }

    } else {  #$homeRadar is on-line
      $#currad = -1;
      @currad[0] = $homeRadar_U;
    }
  }  #if version == 4

#---------------------------------------------------------------------
  foreach (@currad) {
    $radar = $_;

#   find $radar in @lapsrad...if not there, add it
    $lineNo = 0;
    $radNo = 0;
    foreach (@lapsrad) {
      $lineNo++;
      if ($radar eq $_) {
        $radNo = $lineNo;
      }
    }
    
    if ($radNo == 0) {  # $radar not in @lapsrad...add it to radar.lst and @lapsrad
      $lineNo++;
      $radNo = $lineNo;
      print RADARLST "$radar\n";
      push @lapsrad, $radar;
      $lapsradarNo++;
    } 
   
    $radar =~ tr/A-Z/a-z/;
    $inputDir = "$FXA_DATA/radar/$radar/Z/elev0_5/res2/level16";

    if ($radNo < 10) {
      $radNo_c = "00".$radNo;
    } elsif ($radNo < 100) {
      $radNo_c = "0".$radNo;
    } else {
      $radNo_c = $radNo."/";
      chop($radNo_c);
    }
    if ($version == 4) {
      $radNo_c = "001";
    }

    $outputDir = "$LAPS_DATA_ROOT/lapsprd/rdr/$radNo_c/raw";

#---------------------------------------------------------------------
# tfrNarrowband2netCDF requires $radar, $startWin, $endWin, $inputDir, $outputDir on command line
#---------------------------------------------------------------------

    print "Calling parameters:\n";
    print "  radar = $radar\n";
    print "  startWin = $startWin\n";
    print "  endWin = $endWin\n";
    print "  inputDir = $inputDir\n";
    print "  outputDir = $outputDir\n";

    $sys = "$FXA_HOME/bin/$exe $radar $startWin $endWin $inputDir $outputDir";
    &forksub($sys,$lockfile);

  }  # end while (@currad)

  close(RADARLST);
#---------------------------------------------------------------------
  
}
#=====================================================================
#
# run remap_polar_netcdf.exe process
#

$exe = "remap_polar_netcdf.exe";
$log = $exe;
$log =~ s/\..*$/\.log\.$hhmm/;
open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
open(STDOUT, ">$LAPS_LOG_PATH/$log") || die "Can't redirect stdout";
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;
#
# Make sure the requested program exists
#
unless(-x "$LAPSROOT/bin/$exe"){
    die "Program $LAPSROOT/bin/$exe not found or not executable";
}
#
# Look for a previous lock for this exe in the log directory
#

my(@locks);
opendir(LOCKDIR,"$LAPS_LOG_PATH");
@locks = grep /^\.lock$exe/, readdir(LOCKDIR);
closedir(LOCKDIR);

foreach(@locks){
    $_ =~ /^\.lock$exe\.(\d+)$/;
    my $jpid = $1;
    open(LFH,"$LAPS_LOG_PATH/$_");
    my $cid = <LFH>;
    close(LFH);
    next unless ($cid>1);
    open(PS,"ps -ef |");
    my @ps = <PS>;
    close(PS);
#
# Kill any children of the child
#
    foreach(@ps){
	if ($_ =~ /\s+(\d+)\s+$cid\s+/){
	    print "Killing process $1\n";
	    kill -9,$1;
	}
    }
#
# Kill the child
#    
    print "WARNING Found LOCK file for $exe with pid $jpid and child $cid - killing process $cid\n";
    kill -9,$cid if($cid>0);
    unlink "$LAPS_LOG_PATH/$_";
}

$lockfile = "$LAPS_LOG_PATH/\.lock$exe\.$$";

$sys = "$LAPSROOT/bin/$exe ";

&forksub($sys,$lockfile);
exit;

#=====================================================================

sub forksub{
    my($sys,$lockfile) = @_;
  FORK: {      
      my $pid;
      if($pid = fork) {
	  # parent process
	  open(LOCK,">$lockfile");
	  print LOCK "$pid\n";
	  close(LOCK);
	
	  waitpid $pid,0;
	  unlink "$lockfile";


      }elsif (defined $pid) { 
	  #child here
	  exec($sys);
	  unlink "$lockfile";
	  exit;
      }elsif ($! =~ /No more process/){
	  # EAGAIN, recoverable fork error
	  sleep 5;
	  redo FORK;
      }else{
	  die "Can't fork: $!\n";
      }
  }
}






