      subroutine pk_sect6(kfildo,ib,nxy,ipack,nd5,locn,ipos,
     1                    is6,ns6,ipkopt,l3264b,ier,isevere,*)
c
c        march    2000   glahn   tdl   for grib2
c        january  2001   glahn   comments; added check on size of
c                                is5( ) and on is6(5) = 6
c        january  2001   glahn/lawrence commnets; removed is6(5) = 6
c        march    2001   lawrence removed test that determines whether
c                        or not section 6 is large enough to contain
c                        the entire bit-map.  section 6 need only be
c                        6 octets large.  the bitmap is stored in 
c                        ib( ).
c        november 2001   glahn   reversed order of ier = 601 and 602  
c
c        purpose
c            packs section 6, the bit map section, of a grib2 message.
c
c        data set use
c           kfildo - unit number for output (print) file. (output)
c
c        variables
c              kfildo = unit number for output (print) file. (input)
c               ib(j) = bit map to pack (j=1,nxy).  (input)
c                 nxy = the number of values in ib( ).  (input)
c            ipack(j) = the array that holds the actual packed message
c                       (j=1,nd5). (input/output)
c                 nd5 = the size of the array ipack( ). (input)
c                locn = the word position to place the next value.
c                       (input/output)
c                ipos = the bit position in locn to start placing
c                       the next value. (input/output)
c              is6(j) = contains the bit map information 
c                       corresponding to section 6 of grib2 (j=1,ns6).
c                       (input/output)
c                 ns6 = size of is6( ). (input)
c              ipkopt = packing indicator:
c                       0 = error, don't pack
c                       1 = pack ia( ), simple
c                       2 = pack ia( ) and ib( ), simple
c                       3 = pack complex or spatial differencing
c                       4 = pack complex.
c                       (output)
c              l3264b = the integer word length in bits of the machine
c                       being used. values of 32 and 64 are
c                       accommodated. (input)
c                 ier = return status code. (output)
c                         0 = good return.
c                       1-4 = error codes generated by pkbg. see
c                             the documentation in the pkbg
c                             routine.
c                       601 = is6(5) does not indicate section 6.
c                       602 = is6( ) has not been dimensioned large 
c                             enough to contain section 6.
c             isevere = the severity level of the error.  the only
c                       value retuned is:
c                       2 = a fatal error  (output)
c                   * = alternate return when ier ne 0.
c
c             local variables
c                   n = l3264b = the integer word length in bits of
c                       the machine being used. values of 32 and
c                       64 are accommodated.
c               izero = 0.
c               ifill = number of bits necessary to fill out an octet.
c             locn6_1 = the word position to store the length
c                       of section 6 into.
c             ipos6_1 = the bit position in locn6_1 to store the
c                       length of section 6 into.
c
c        non system subroutines called
c           pk_bmap,pkbg
c
      dimension ipack(nd5),is6(ns6)
c
      data izero/0/
c
      n=l3264b
      ier=0
c
c        all errors generated by this routine are fatal.
      isevere=2
c
c        the length of the mandatory section is 6 octets.
c
      if(ns6.lt.6)then
         ier=602
         go to 900
      endif
c
      if(is6(5).ne.6)then
c           a section 6 is required even though there is no bitmap.
         ier=601
         go to 900
      endif
c
c        save the word and bit positions to pack the total length
c        of section 6 into. 
      locn6_1=locn
      ipos6_1=ipos
      call pkbg(kfildo,ipack,nd5,locn,ipos,izero,32,n,ier,*900)
c
c        pack the section number.
      call pkbg(kfildo,ipack,nd5,locn,ipos,is6(5),8,n,ier,*900)
c
c        pack the bit-map indicator
      call pkbg(kfildo,ipack,nd5,locn,ipos,is6(6),8,n,ier,*900)
c
      if(ipkopt.eq.2)then
c           pack the bit map.
         call pk_bmap(kfildo,ib,nxy,ipack,nd5,locn,ipos,
     1                l3264b,ier,*900)
      endif
c
c        pad with zeros to fill out an octet, if necessary.
c
      ifill=mod(33-ipos,8)
c
      if(ifill.ne.0)then
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,ifill,n,ier,*900)
      endif
c
      is6(1)=length(kfildo,ipack,nd5,n,locn6_1,ipos6_1,locn,
     1              ipos,ier)
c***d     write(kfildo,800)locn6_1,ipos6_1,locn,ipos,lentgh
c***d800  format(/' in pk_sect6 at 800--locn6_1,ipos6_1,locn,ipos,lentgh',
c***d    1       5i9)
c
c        error return section
c
 900  if(ier.ne.0)return 1
c
      return
      end
