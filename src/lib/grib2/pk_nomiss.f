      subroutine pk_nomiss(kfildo,ia,ib,nxy,minpk,ifirst,
     1                     isecond,imina,numoctet,second,
     2                     ier)
c
c        february 1994   glahn   tdl   mos-2000
c        march    1997   glahn   slight diagnostic change.
c        march    2000   glahn   revised for grib2;
c                                changed name from packxx
c        april    2000   lawrence revised for still more updates
c                                to grib2 documentation.
c        january  2001   glahn   comments; eliminated array ibxx2( );
c                                changed ier = 1100 to 920
c        november 2001   glahn   added ier=0 at beginning;
c                                eliminated unused izer0
c        november 2001   glahn   changed numoctet=(numbit/8)+1 to
c                                numoctet=(numbit+7)/8 near the end
c        january  2002   glahn   added test for 1st order diff ge
c                                2**15.; modified comment for ier = 920
c        january  2002   glahn   added mallow = 2**30+1 and used instead
c                                of 999999 for jmax and jmin
c        december 2002   taylor/glahn   changed statement 225 from
c                                'if(ivalue.lt.0)numbit=numbit+1' to
c                                numbit=numbit+1 to allow for sign
c
c        purpose 
c            determines whether or not to use second order
c            differences or original values to pack.  original values
c            are indicated when the average range of consecutive groups
c            of size minpk of the second order differences is
c            larger than the average range of consecutive groups of
c            size minpk of the original values.  note that this 
c            procedure does not in general use the same groups as are
c            used in the actual packing because it does not employ the
c            lookback procedure.  this algorithm is relatively cheap
c            and gives a result good enough for the purpose.  this
c            routine is not used when there are missing values 
c            (i.e., a missing value indicator is in the data).
c            when using second order differences is not to be done,
c            ia( ) is unchanged; when they are to be used, ia( )
c            contains those differences with the first 2 locations
c            dummy (actually, ia(1) = ia(2) = 0.
c
c        data set use 
c           kfildo - unit number for output (print) file. (output) 
c
c        variables 
c              kfildo = unit number for output (print) file.  (input) 
c               ia(k) = holds the nxy original values on
c                       input (k=1,nxy).
c                       holds the nxy-2 second order differences on
c                       output when second order differences are to be
c                       used.  in that case, second is .true.
c                       (input-output)
c               ib(k) = work array (k=1,nxy).  (internal)
c                 nxy = number of values in ia( ) on input.
c                       used as dimension of ia( ) and ib( ).
c                       (input)
c               minpk = increment in which ranges will be computed.
c                       (input)
c              ifirst = ifirst is the first original value.  (output)
c             isecond = isecond is the second original value. (output)
c               imina = the overall minimum value of the second order
c                       spatial differences. (output)
c            numoctet = the minimum number of octets required to
c                       pack the values represented by ifirst,
c                       isecond, and imina. (output)
c              second = true (false) when second order differences
c                       are (are not) to be used.  (output)
c                 ier = contains any error codes generated by this
c                       routine
c                         0 = good return
c                       920 = a value larger than what can be packed
c                             into 30 bits has been encountered. 
c
c             local variables
c                avgr = contains the average range of nxy values
c                       in increments of minpk for the original
c                       data field in ia( ).
c               avgr2 = contains the average range of nxy values
c                       in increments of minpk for the data field
c                       with second order differences in ib( ).
c               cfeed = contains the character representation
c                       of a printer form feed.
c               ifeed = contains the integer value of a printer
c                       form feed.
c              irange = the difference of jmax and jmin.
c              ivalue = the value of ifirst, isecond, and imina
c                       that will need the most octets to store.
c           jmax,jmin = used to keep track of the max and min values
c                       of a particular group of minpk values.
c              jfirst = contains the absolute value of the first
c                       non-missing value in the original data
c                       field.
c            jlargest = contains the largest of jfirst, jsecond, and
c                       jmina for the purpose of determining
c                       how many octets to store all three values
c                       in.
c               jmina = contains the absolute value of the minimum
c                       of the field of second order differences.
c             jsecond = contains the absolute value of the second
c                       non-missing value in the original data
c                       field.
c                  k = loop index variable.
c               kount = a counting/looping variable.
c                sumr = used in computing the average range of the
c                       original nxy values in increments of minpk.
c               large = 2**15, the largest 1st order difference
c                       tolerated.  if the 1st order difference 
c                       exceeds this value, it is likely the 2nd
c                       order difference will overflow the integer
c                       computation and cause an undetected error.
c
c        non system subroutines called
c           none
c
      parameter (mallow=2**30+1)
      parameter (large=2**15)
c
      character*1 cfeed
      logical second
c
      dimension ia(nxy),ib(nxy)
c 
      data ifeed/12/
c
      ier=0
c
c        initialize the form feed character.
      cfeed=char(ifeed)
c
c        compute first order differences and initialize ifirst and
c        isecond.
      ifirst=ia(1)
      isecond=ia(2)
c
      do 120 k=1,nxy-1
         ib(k)=ia(k+1)-ia(k)
c         
         if(ib(k).gt.large)then
            second=.false.
c           write(kfildo,119)            
c119        format(/' 1st order difference exceeds 2**15.',
c    1              '  second order differences are not pakced.')
           go to 900
        endif
c
 120  continue
c
c     write(kfildo,121)(ia(k),k=1,nxy)
c121  format(/' original scaled values'/(' '20i6))
c
c***d     write(kfildo,122)(ib(k),k=1,nxy-1)
c***d122  format(/ 'first order differences'/(' '20i6))
c
c        compute second order differences
c
      do 130 k=1,nxy-2
         ib(k)=ib(k+1)-ib(k)
 130  continue
c
c        compute the minimum of the field of second order
c        differences and subtract it from of each of the
c        values in the field.
      imina=ib(1)
c
      do 132 k=2,nxy-2
         if(ib(k).lt.imina)imina=ib(k)
 132  continue
c
      do 134 k=1,nxy-2
         ib(k)=ib(k)-imina
 134  continue
c
c        compute average range of nxy original values in increments of 
c        minpk.
      sumr=0
      kount=0
c 
      do 140 k=1,nxy,minpk
      jmin=mallow
      jmax=-mallow
      if(k+minpk-1.gt.nxy)go to 140
c        the last group may be very small and not be representative of
c        the range.
c
      do 135 j=k,k+minpk-1
      if(ia(j).gt.jmax)jmax=ia(j)
      if(ia(j).lt.jmin)jmin=ia(j)
 135  continue
c
      kount=kount+1
      irange=jmax-jmin
      sumr=sumr+irange    
 140  continue
c
      avgr=99999.
      if(kount.ne.0)avgr=sumr/kount
c
c        compute average range of nxy-2 2nd order values in increments of 
c        minpk.
c
      sumr=0
      kount=0
c
      do 150 k=1,nxy-2,minpk
      jmin=mallow
      jmax=-mallow
      if(k+minpk-1.gt.nxy-2)go to 150
c        the last group may be very small and not be representative of
c        the range.
c
      do 145 j=k,k+minpk-1
      if(ib(j).gt.jmax)jmax=ib(j)
      if(ib(j).lt.jmin)jmin=ib(j)
 145  continue
c
      kount=kount+1
      irange=jmax-jmin
      sumr=sumr+irange    
 150  continue
c
      avgr2=99999.
      if(kount.ne.0)avgr2=sumr/kount
c
c     write(kfildo,155)avgr,avgr2
c155  format(/' average range of original scaled values =  'f10.2/
c    1        ' average range of second order differences ='f10.2)
c
      if(avgr2.ge.avgr)then
c
c           original values will be packed.  ia( ) has not been
c           disturbed.
c
         second=.false.
      else
c
c           second order differences will be packed.  transfer
c           them from ib( ) to ia( ).
c
c***d     write(kfildo,160)
c***d160  format(' second order differences will be packed')
c
c
         ia(1)=0
         ia(2)=0
c
         do 200 k=1,nxy-2
            ia(k+2)=ib(k)
 200     continue
c
c***d    write(kfildo,201)(ia(k),k=1,200)
c***d201 format(/' second order differences to be packed'/(' '20i6))
c
         second=.true.
c
c           since we are doing second order differences
c           take the time here to determine the minimum
c           number of bytes (not bits) needed to contain 
c           the first original value, the second original
c           value, and the minimum of the field of second
c           order differences.
c
         numbit=0
         jmina=abs(imina)
         jfirst=abs(ifirst)
         jsecond=abs(isecond)
c
c           find the largest absolute value of the 
c           the three variables imina, ifirst, and
c           isecond.
c
         if(jmina.gt.jfirst)then
            jlargest=jmina
            ivalue=imina
         else
            jlargest=jfirst
            ivalue=ifirst
         endif
c
         if(jlargest.lt.jsecond)then
            jlargest=jsecond
            ivalue=isecond
         endif
c
         ibxx2=2
c
         do 220 k=1,30
            numbit=k
            if(jlargest.lt.ibxx2)go to 225
            ibxx2=ibxx2*2
 220     continue
c
c           drop through here means the number of bits
c           exceeds 30 and the value to pack exceeds 2**30.
c           2**31 is too large a value to pack.  2**30 
c           is used as the limit throughout the packer,
c           although a value of 2**31-1 could probably
c           be accommodated.
         ier=920
c           this is a fatal error.
         go to 900
c
 225  numbit=numbit+1
c        allow for sign bit.
c
c           find the smallest number of octets 
c           that will contain the values.  
         numoctet=(numbit+7)/8
c
      endif
c
 900  return
      end
