      subroutine pk_sect1(kfildo,ipack,nd5,is1,ns1,new,l3264b,
     1                    locn,ipos,ier,isevere,*)
c
c        march   2000   lawrence   gsc/tdl   original coding
c        january 2001   glahn      comments; changed is1(5) test; added
c                                  test for size of is1( )
c
c        purpose
c            packs section 1, the identification section, of a grib2
c            message.
c
c        data set use
c           kfildo - unit number for output (print) file. (output)
c
c        variables
c              kfildo = unit number for output (print) file. (input)
c            ipack(j) = the array that holds the actual packed message
c                       (j=1,nd5). (input/output)
c                 nd5 = the size of the array ipack( ). (input)
c              is1(j) = contains the identification data that 
c                       will be packed into ipack( ) (j=1,ns1).
c                       (input)
c                 ns1 = size of is1( ). (input) 
c                 new = when new = 1, this is the first grid to be 
c                       packed in the grib2 message. there must be
c                       a section 1 in this case. when new = 0,
c                       this is not the first grid to be packed into
c                       this message. there should not be a section 
c                       1 in this case. 
c              l3264b = the integer word length in bits of the machine
c                       being used. values of 32 and 64 are
c                       accommodated. (input)
c                locn = the word position to place the next value.
c                       (input/output)
c                ipos = the bit position in locn to start placing
c                       the next value. (input/output)
c                 ier = return status codes. (output)
c                         0 = good return.
c                       1-4 = error codes generated by pkbg. see the 
c                             documentation in the pkbg routine.
c                       5,6 = error codes generated by the length
c                             function. see the documentation for
c                             the length function.
c                       101 = is1(5) ne 1 signifying section 1.
c                       102 = is1( ) has not been dimensioned large
c                             enough.
c             isevere = the severity level of the error.  the only
c                       value retuned is:
c                       2 = a fatal error  (output)
c                   * = alternate error return. (output)
c
c             local variables
c               ipos1 = saves the bit position in locn1
c                       to store the length of section 1
c                       after the routine is done packing
c                       data into the section.
c               izero = contains the value '0'.  this is used in the
c                       code simply to emphasize that a certain 
c                       group of octets in the message are being 
c                       zeroed out.
c                   k = a looping index variable.
c                loc1 = saves the word position in ipack
c                       to store the length of section 1
c                       after the routine is done packing
c                       data into the section.
c                   n = l3264b = the integer word length in bits of
c                       the machine being used. values of 32 an
c                       64 are accommodated
c             minsize = the minimum size for is1( ).  is2(21) is
c                       filled in pk_sect1.  this only applies when
c                       this is a "new" message.      
c
c        non system subroutines called
c           length,pkbg
c
      parameter(minsize=21)
c
      dimension ipack(nd5),is1(ns1)
c
      data izero/0/
c
      n=l3264b
      ier=0
c
c        all errors generated by this routine are fatal.
      isevere=2
c
c        in the case of packing a grib2 message with multiple
c        grids determine if a section 1 is required.
c
      if(new.eq.1)then
c
c        check minimum size of is1( ).
c
         if(ns1.lt.minsize)then
            ier=102
            go to 900
         endif
c
         if(is1(5).ne.1)then
            ier=101
            go to 900
         endif
c
         loc1 = locn
         ipos1 = ipos
c
c           the first four bytes hold the length of the section.
c           zero them out for now, and fill them in later.
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,32,n,ier,*900)
c
c           pack the number of the section.
         call pkbg(kfildo,ipack,nd5,locn,ipos,1,8,n,ier,*900)
c
c           pack id of originating/generating centre
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(6),16,n,ier,*900)
c
c           pack id of originating/generating sub-centre
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(8),16,n,ier,*900)
c
c           pack grib master and local tables version numbers.
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(10),8,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(11),8,n,ier,*900)
c
c           pack significance of reference time
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(12),8,n,ier,*900)
c
c           pack the year, day, month, hour, minute, and second
c           of the data.
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(13),16,n,ier,*900)
c
         do k=15,19
            call pkbg(kfildo,ipack,nd5,locn,ipos,is1(k),8,n,ier,*900)
         enddo
c
c           pack the production status and type of processed data
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(20),8,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,is1(21),8,n,ier,*900)
c
c           compute the length of the section and pack it.  loc1 and
c           ipos1 represent the position of the first byte in section
c           1.  8 is the number of bits in a byte, and each section
c           ends at the end of a byte.
         is1(1)=length(kfildo,ipack,nd5,l3264b,loc1,ipos1,locn,
     1                 ipos,ier)
      endif
c
c       error return section
 900  if(ier.ne.0)return 1
c
      return
c
      end
