      subroutine pk_cmplx(kfildo,ia,nxy,ipack,nd5,locn,ipos,
     1                    is5,ns5,is7,ns7,inc,minpk,missp,
     2                    misss,ibit,locn5_32,ipos5_32,l3264b,
     3                    ier,*)
c
c        september 1994   glahn    tdl   hp
c        june      1999   lawrence updated this routine to be used
c                                  with grib2.  the actual method
c                                  of packing is unchanged.
c        march     2000   lawrence updated to reflect minor changes
c                                  in the grib2 documentation.
c        march     2000   glahn    restructured
c        january   2001   glahn    comments; changed error code numbers;
c                                  added ier and * to call to pack_gp
c        november  2001   glahn    changed numbits=(is5(48)*8)-1 to
c                                  numbits=(is5(49)*8)-1; added * to
c                                  900 in return from pack_gp
c        march     2002   glahn    added iersav=0
c        purpose
c            packs data at "units" resolution provided in
c            ia( ).  values are taken out at nonuniform steps with 
c            a minimum group size of minpk.  packing conforms with 
c            the wmo standard grib2. is5( ) corresponds to 
c            grib2 section 5.
c
c            the following equation is used to pack the data:
c               x1 = [(y - r) * (2 ** -e) * (10 ** -d)] - x2
c                    x1 = the packed value
c                     y = the value we are packing
c                     r = the reference value (first order minima)
c                     e = the binary scale factor
c                     d = the decimal scale factor
c                    x2 = the second order minima
c            r has already been removed upon entry.
c
c        data set use 
c           kfildo - unit number for output (print) file. (output) 
c
c        variables 
c              kfildo = unit number for output (print) file.  (input) 
c               ia(k) = data to pack (k=1,nxy).  (input)
c                 nxy = the dimension of ia( ). (input) 
c            ipack(j) = the array to hold the actual packed message
c                       (j=1,max of nd5).  (input/output)
c                 nd5 = dimension of ipack( ).  (input)
c                locn = the word position to place the next value.
c                       (input/output)
c                ipos = the bit position in locn to start placing
c                       the next value. (input/output)
c              is5(k) = contains data that corresponds to section
c                       5 of the grib2 message (k=1,ns5). 
c                       (input/output)
c                 ns5 = dimension of is5( ). (input)
c              is7(k) = contains the grid definition data that
c                       will be packed into ipack( ) (k=1,ns7).
c                       (input)
c                 ns7 = size of is7( ). (input)
c                 inc = number of values to add to the group to be
c                       packed at a time.  (input)
c               minpk = values are packed in groups of minimum size
c                       minpk.  only when the number of bits to handle
c                       a group changes will a new group be formed.
c                       (input)
c               missp = the primary missing value.  (input)
c               misss = the secondary missing value.  (input)
c               ibit =  the number of bits required to pack the group
c                       minimum values.  (output)
c           locn5_32 = locn for octet 32 in section 5.  (input)
c           ipos5_32 = ipos for octet 32 in section 5.  (input)
c              l3264b = contains the number of bits in a word
c                       implemented on this particular platform.
c                       (input).
c                 ier = error return
c                       1-4 = error codes generated by pkbg. see the 
c                             documentation in the pkbg routine.
c                       705 = nd5 is not large enough to accommodate the
c                             bits necessary to pack the values starting
c                             at the values locn and ipos.  returned from
c                             pk_s7.
c                       711 = lbit incorrect.
c                       712 = incorrect splitting method.
c                       713 = unrecognized missing value flag
c                             in is5(23).  (output)
c                   * = alternate return when ier ne 0.
c
c        local variables
c               ifill = number of bits to pad message (at that point
c                       in the process) to an even octet.
c              ifirst = keeps track of whether or not this is the
c                       first time that this routine has been called.
c               izero = contains 0.
c             jmax(m) = the maximum of each group m of packed values
c                       after subtracting the group minimum value
c                       (m=1,lx). (not actually used)  (automatic)
c             jmin(m) = the minimum value subtracted for each group m
c                       (m=1,lx).  (automatic)
c              nov(m) = the number of values in group m (m=1,lx).
c                       after the reference value is removed.
c                       (automatic)
c              novref = the reference value for nov( ).
c                kbit = the number of bits used to pack the width
c                       of widths.
c               lb2m1 = contains the powers of two allowing for
c                       one missing value.
c              lb2m1l = contains the number of bits to pack a value
c                       in when there are only primary missing values.
c               lb2m2 = contains the powers of two allowing for
c                       two missing values.
c              lb2m2l = contains the number of bits to pack a value
c                       in when there are both primary and 
c                       secondary missing values.
c             lbit(m) = the number of bits necessary to hold the
c                       packed values for each group m (m=1,lx)
c                       after the reference is removed.  (automatic)
c             lbitref = the reference value for lbit( ).
c                kbit = the width of the group minima.
c                  lx = the number of groups.
c              ncount = counts the values actually packed.  this can be
c                       less than nxy when one or more groups have the
c                       same value, and the values are omitted.
c                       (not actually used.)
c                   n = local value of l3264b.
c
c        non system subroutines called 
c           pack_gp, pkbg, pk_s7, pk_c7
c
      dimension ia(nxy)
      dimension jmax(nxy),jmin(nxy),nov(nxy),lbit(nxy)
c        jmax( ), jmin( ), nov( ), and lbit( ) are automatic arrays.
c        it is likely dimensions of nxy/minpk would suffice.
      dimension ipack(nd5)
      dimension is5(ns5),is7(ns7)
      dimension lb2m1(0:30),lb2m2(0:30)
c
      save lb2m1,lb2m2
c
      data izero/0/
      data ifirst/0/
c
c         calculate the powers of 2 the first time entered.
c
      ier=0
      iersav=0
      n=l3264b
c
      if(ifirst.eq.0)then
         ifirst=1
         lb2m1(0)=0
         lb2m2(0)=-1
c
         do 100 j=1,30
            lb2m1(j)=(lb2m1(j-1)+1)*2-1
            lb2m2(j)=(lb2m2(j-1)+2)*2-2
 100     continue
c
      endif
c
      if(is5(22).ne.1)then
c
c           only the "general" grouping (or splitting) method
c           is supported.
         ier=712
         go to 900
      endif
c
      call pack_gp(kfildo,ia,nxy,is5,ns5,minpk,inc,missp,misss,
     1             jmin,jmax,lbit,nov,nxy,lx,ibit,jbit,kbit,
     2             novref,lbitref,ier,*900)     
      iersav=ier
      ier=0
c        iersav can be used in the calling routine to provide
c        error tracing.  subroutine reduce can produce non
c        fatal errors.  other errors are fatal and return is
c        to *900.
c
c        subtract local min for each of lx groups.
c        separate loops used for efficiency, depending
c        on possibility of missing values.
      if(is5(23).eq.0)then
c           there are no missing values.
         k=0
c
         do 120 l=1,lx
            do 119 m=1,nov(l)+novref
               k=k+1
               ia(k)=ia(k)-jmin(l)
 119        continue
 120     continue
c
      elseif(is5(23).eq.1)then
c           there are no secondary missing values.
c
         k=0
c
         do 130 l=1,lx
         lb2m1l=lb2m1(lbit(l)+lbitref)
c
         do 129 m=1,nov(l)+novref
         k=k+1
c
         if(ia(k).eq.missp)then
            ia(k)=lb2m1l
         else
            ia(k)=ia(k)-jmin(l)
         endif
c
 129     continue
 130     continue
c
      elseif(is5(23).eq.2)then
c           there are both primary and secondary missing values.
c
         k=0
c
         do 140 l=1,lx
         lb2m1l=lb2m1(lbit(l)+lbitref)
         lb2m2l=lb2m2(lbit(l)+lbitref)
c
         if((lbit(l)+lbitref).lt.2)then
c           write(kfildo,135)lbit(l),misss
c135        format(/' ****lbit(l) ='i2,' is lt 2 in pk_cmplx',
c    1              ' for misss ='i5)
            ier=711
            go to 900
         endif
c
         do 139 m=1,nov(l)+novref
         k=k+1
c
         if(ia(k).eq.missp)then
            ia(k)=lb2m1l
         elseif(ia(k).eq.misss)then
            ia(k)=lb2m2l
         else
            ia(k)=ia(k)-jmin(l)
         endif
c
 139     continue
 140     continue
c
      else
c
c           invalid value in is5(23).
         ier=713
         goto 900
      endif
c
c        fill appropriate elements of is5( ).
c
      is5(32)=lx
      is5(36)=lbitref
      is5(37)=jbit
      is5(38)=novref
      is5(42)=1
      is5(43)=nov(lx)+novref
      is5(47)=kbit
c
c        temporary diagnostic output for complex packing.
c     write(kfildo,101)ibit
c101  format(/' number of bits to pack the group references = ',i6)
c     write(kfildo,102)jbit, lbitref
c102  format(/' number of bits to pack group widths =         ',i6,//
c    1        ' reference for group widths =                  ',i6)
c     write(kfildo,103)kbit, novref
c103  format(/' number of bits to pack the group lengths =    ',i6,//
c    1        ' reference for group lengths =                 ',i6)
c     write(kfildo,104)is5(42)
c104  format(/' lentgh increment for group lengths =          ',i6)
c     write(kfildo,105)is5(43)
c105  format(/' last group''s true length =                  ',i8)
c     write(kfildo,106)lx
c106  format(/' the number of groups in the packed message =',i8,//)
c
c***d     do 110 j=1,lx
c***d        write(kfildo,115) j,nov(j),jmin(j),lbit(j)
c***d115     format(' group ',i6,'     length = ',i8,'     ref = ',i8,
c***d    1           '     width = ',i6)
c***d110  end do
c
      locn5=locn5_32
      ipos5=ipos5_32
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(32),32,n,ier,*900)
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(36),8,n,ier,*900)
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(37),8,n,ier,*900)
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(38),32,n,ier,*900)
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(42),8,n,ier,*900)
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(43),32,n,ier,*900)
      call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(47),8,n,ier,*900)
c
      if(is5(10).eq.3)then
         call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(48),8,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn5,ipos5,is5(49),8,n,ier,*900)
c
c           pack the additional information for second order
c           differencing in section 7 here (the first and second
c           original values and the minimum of the field of
c           second order differences).
         numbits=(is5(49)*8)-1
         isign=0
         if(is7(6).lt.0)isign=1
         call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,abs(is7(6)),
     1             numbits,n,ier,*900)
         isign=0
         if(is7(7).lt.0)isign=1
         call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,abs(is7(7)),
     1             numbits,n,ier,*900)
         isign=0
         if(is7(8).lt.0)isign=1
         call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,abs(is7(8)),
     1             numbits,n,ier,*900)
      endif
c
c        pack the minimum values for each group--the group
c        reference values.  note that this uses locn,ipos, not
c        the locn5,ipos5 from directly above.
c
      call pk_s7(kfildo,ipack,nd5,locn,ipos,jmin,lx,ibit,n,ier,*900)
c
c        pad with zero bits to fill out an octet.
c
      ifill=mod(33-ipos,8)
c
      if(ifill.ne.0)then
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,ifill,n,ier,*900)
      endif
c
c        pack the number of bits required for the values in
c        each group--the group widths.
c
      call pk_s7(kfildo,ipack,nd5,locn,ipos,lbit,lx,jbit,n,ier,*900)
c
c        pad with zero bits to fill out an octet.
c
      ifill=mod(33-ipos,8)
c
      if(ifill.ne.0)then
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,ifill,n,ier,*900)
      endif
c
c        pack the lengths of each group.
c
      call pk_s7(kfildo,ipack,nd5,locn,ipos,nov,lx,kbit,n,ier,*900)
c
c        pad with zero bits to fill out an octet.
c
      ifill=mod(33-ipos,8)
c
      if(ifill.ne.0)then
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,ifill,n,ier,*900)
      endif
c
c        pack the values, with both first and second order minima out.
c
      ncount=0
c
c        put the field width and bit references back into 
c        nov and lbit for the purpose of packing the actual
c        values.  these were removed in pack_gp.
      do k=1,lx
         nov(k)=nov(k)+novref
         lbit(k)=lbit(k)+lbitref
      enddo
c
      call pk_c7(kfildo,ipack,nd5,locn,ipos,ia,nxy,nov,lbit,lx,
     1           n,ncount,ier,*900)
c
c        pad with zero bits to fill out an octet.
c
      ifill=mod(33-ipos,8)
c
      if(ifill.ne.0)then
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,ifill,n,ier,*900)
      endif
c
 900  if(ier.ne.0)return1
c
      if(iersav.ne.0)ier=iersav
      return
      end
