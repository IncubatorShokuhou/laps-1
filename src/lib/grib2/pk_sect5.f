      subroutine pk_sect5(kfildo,ipack,nd5,is5,ns5,mina,xmina,
     1                    missp,xmissp,misss,xmisss,l3264b,
     2                    locn,ipos,locn5_20,ipos5_20,locn5_32,
     3                    ipos5_32,ier,isevere,*)
c
c        march    2000   glahn   tdl   for grib2
c        january  2001   glahn   comments; eliminated tvalue; added
c                                check on size of is5( )
c        january  2001   glahn/lawrence restructured to check ns5
c                                based on packing type
c        february 2001   glahn/lawrence changed ns5.lt.10 to lt.21
c                                for case (0); eliminated packing
c                                reference value as integer; comments
c        november 2001   glahn   changed test on ns5 from 10 to 21 
c                                for simple packing.
c        december 2001   glahn   moved test on is5(10) to prepr
c
c        purpose
c            packs section 5, the data representation section,
c            of a grib2 message.  this supports only simple,
c            complex, and complex with spatial differencing.
c
c        data set use
c           kfildo - unit number for output (print) file. (output)
c
c        variables
c              kfildo = unit number for output (print) file. (input)
c            ipack(j) = the array that holds the actual packed message
c                       (j=1,nd5). (input/output)
c                 nd5 = the size of the array ipack( ). (input)
c              is5(j) = contains the data representation data that
c                       will be packed into ipack( ) (j=1,ns5).
c                       (input/output)
c                 ns5 = size of is5( ). (input)
c                mina = reference value when integer.  (input)
c               xmina = reference value when floating point.  (input)
c               missp = primary missing value, when integer.  (input)
c              xmissp = primary missing value, when floating point.
c                       (input)
c               misss = secondary missing value, when integer.  (input)
c              xmisss = secondary missing value, when floating point.
c                       (input)
c              l3264b = the integer word length in bits of the machine
c                       being used. values of 32 and 64 are
c                       accommodated.  (input)
c                locn = the word position to place the next value.
c                       (input/output)
c                ipos = the bit position in locn to start placing
c                       the next value. (input/output)
c           locn5_20 = locn for octet 20 in section 5.  (output)
c           ipos5_20 = ipos for octet 20 in section 5.  (output)
c           locn5_32 = locn for octet 32 in section 5.  (output)
c           ipos5_32 = ipos for octet 32 in section 5.  (output)
c                ier = return status code. (output)
c                        0 = good return.
c                      1-4 = error codes generated by pkbg. see the
c                            documentation in the pkbg routine.
c                      501 = is5(5) does not indicate section 5.
c                      502 = is5( ) has not been dimensioned large
c                            enough to continue section 5.
c             isevere = the severity level of the error.  the only
c                       value retuned is:
c                       2 = a fatal error  (output)
c                  * = alternate return when ier ne 0 from
c                      subroutines.
c
c             local variables
c              ivalue = the integer equivalence of the 'ieee' real
c                       number contained in rvalue.
c               izero = contains the value '0'.  this is used in the
c                       code simply to emphasize that a certain 
c                       group of octets in the message are being 
c                       zeroed out.
c                   n = l3264b = the integer word length in bits of
c                       the machine being used. values of 32 and
c                       64 are accommodated.
c              rvalue = contains a real number in ieee format.
c               isign = sign of value being packed, 0 = positive,
c                       1 = negative.  the sign always goes in the
c                       leftmost bit of the area assigned to that value.
c
c        non system subroutines called
c           fmkieee, pkbg
c
      dimension ipack(nd5),is5(ns5)
c
      data izero/0/
c
      equivalence(rvalue,ivalue)
c
      ier=0
      n=l3264b
c
c        all errors generated by this routine are fatal.
c 
      isevere=2
c
c        check to make sure that is5(5) specifies section 5.
c
      if(is5(5).ne.5)then
         ier=501
      else
c
c           check minimum size of is5( ), which depends on
c           packing method.
c
         select case (is5(10))
c
            case (0)
c                 this case is for simple packing.
c
               if(ns5.lt.21)then
                  ier=502
                  go to 900
               endif
c
            case (2)
c                 this case is for complex packing.
c
               if(ns5.lt.47)then
                  ier=502
                  go to 900
               endif
c
            case (3)
c                 this case is for complex packing with second
c                 order differences.
c
               if(ns5.lt.49)then
                  ier=502
                  go to 900
               endif
c         
         end select
c
c           pack section length.  is5(1) is initialized by prepr.
         call pkbg(kfildo,ipack,nd5,locn,ipos,is5(1),32,n,ier,*900)
c
c           pack the section number.  is5(5) is input by the user.
         call pkbg(kfildo,ipack,nd5,locn,ipos,is5(5),8,n,ier,*900)
c
c           pack the number of data points.  is5(6) is initialized
c           by prepr.
         call pkbg(kfildo,ipack,nd5,locn,ipos,is5(6),32,n,ier,*900)
c
c           pack the data representation template number.  is5(10)
c           is provided by the user, but may be overridden by prepr.
         call pkbg(kfildo,ipack,nd5,locn,ipos,is5(10),16,n,ier,*900)
c
c           the following section is for simple, complex, and complex
c           with second order difference packing.
c
c           pack the reference value.  it may be integer or
c           floating point, but is packed as floating point.
c           is5(12) is the scaled value, and may not be of any
c           use to the user, particularly when the data were
c           floating point.
c
         if(is5(21).eq.0)then
c              this is floating point.
            is5(12)=nint(xmina)
         else
c              this is integer.
            xmina=mina
            is5(12)=mina
         endif
c
         rvalue=fmkieee(xmina)
c           rvalue and ivalue are equivalenced.
         call pkbg(kfildo,ipack,nd5,locn,ipos,ivalue,32,n,ier,*900)
c
c            pack the binary and decimal scale factors taking into
c            account that these values may be negative.
c
         isign=0
         if(is5(16).lt.0) isign=1
         call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,abs(is5(16)),15,n,
     1             ier,*900)
         isign=0
         if(is5(18).lt.0) isign=1
         call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
         call pkbg(kfildo,ipack,nd5,locn,ipos,abs(is5(18)),15,n,
     1             ier,*900)
c         
c           save location for field width for the data.
c
         locn5_20=locn
         ipos5_20=ipos
         call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,ier,*900)
c       
c           pack the type of the original field values.
c
         call pkbg(kfildo,ipack,nd5,locn,ipos,is5(21),8,n,ier,*900)
c
c           the following section is for only complex, and complex
c           with second order difference packing.
c
         if(is5(10).ne.0)then
c
c              the packing method is complex or spatial differencing.
c              pack the splitting method.
c
            call pkbg(kfildo,ipack,nd5,locn,ipos,is5(22),8,n,ier,*900)
c
c              pack the provision for missing values.
c
            call pkbg(kfildo,ipack,nd5,locn,ipos,is5(23),8,n,ier,*900)
c
c              pack the primary and secondary missing values.  they
c              may be packed either integer or floating point consistent
c              with the original data (template 5.2, note 7).
c
            if(is5(21).eq.0)then
c
c                 the missing values are floating point.
c
               is5(24)=nint(xmissp)
               rvalue=fmkieee(xmissp)
               call pkbg(kfildo,ipack,nd5,locn,ipos,ivalue,32,n,
     1                   ier,*900)
c
               is5(28)=nint(xmisss)
               rvalue=fmkieee(xmisss)
               call pkbg(kfildo,ipack,nd5,locn,ipos,ivalue,32,n,
     1                   ier,*900)
c
            else
c
c                 the missing values are integer.
c
               is5(24)=missp
               isign=0
               if(missp.lt.0)isign=1
               call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
               call pkbg(kfildo,ipack,nd5,locn,ipos,abs(missp),31,n,
     1                   ier,*900)
               is5(28)=misss
               isign=0
               if(misss.lt.0)isign=1
               call pkbg(kfildo,ipack,nd5,locn,ipos,isign,1,n,ier,*900)
               call pkbg(kfildo,ipack,nd5,locn,ipos,abs(misss),31,n,
     1                   ier,*900)
            endif
c         
c              save the locations for the remainder of section 5.
c
            locn5_32=locn
            ipos5_32=ipos
c
c              save space for the remainder of section 5.  these will
c              be filled by pk_sect7.
c                                  
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,32,n,ier,*900)
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,ier,*900)
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,ier,*900)
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,32,n,ier,*900)
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,ier,*900)
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,32,n,ier,*900)
            call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,ier,*900)
c
c              the following section is for only complex with second
c              order difference packing.
c
            if(is5(10).eq.3)then
               call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,
     1                   ier,*900)
               call pkbg(kfildo,ipack,nd5,locn,ipos,izero,8,n,
     1                   ier,*900)
c
            endif
c
         endif           
c
      endif
c
c        error return section
 900  if(ier.ne.0)return 1
c
      return
      end
